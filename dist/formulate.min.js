var VueFormulate = (function (isPlainObject$1, vueFormulateI18n) {
  'use strict';

  /**
   * library.js
   *
   * Note: We're shipping front end code here, file size is critical. This file is
   * overly terse for that reason alone, we wouldn't necessarily recommend this.
   */
  var fi = 'FormulateInput';
  var add$1 = function (n, c) { return ({
    classification: n,
    component: fi + (c || (n[0].toUpperCase() + n.substr(1)))
  }); };
  var library = Object.assign({}, [
      'text',
      'email',
      'number',
      'color',
      'date',
      'hidden',
      'month',
      'password',
      'search',
      'tel',
      'time',
      'url',
      'week',
      'datetime-local'
    ].reduce(function (lib, type) {
      var obj;

      return (Object.assign({}, lib, ( obj = {}, obj[type] = add$1('text'), obj )));
  }, {}),

    // === SLIDER INPUTS
    {range: add$1('slider'),

    // === MULTI LINE TEXT INPUTS
    textarea: add$1('textarea', 'TextArea'),

    // === BOX STYLE INPUTS
    checkbox: add$1('box'),
    radio: add$1('box'),

    // === BUTTON STYLE INPUTS
    submit: add$1('button'),
    button: add$1('button'),

    // === SELECT STYLE INPUTS
    select: add$1('select'),

    // === FILE TYPE
    file: add$1('file'),
    image: add$1('file'),

    // === GROUP TYPE
    group: add$1('group')});

  /**
   * Function to map over an object.
   * @param {Object} obj An object to map over
   * @param {Function} callback
   */
  function map$1 (original, callback) {
    var obj = {};
    for (var key in original) {
      obj[key] = callback(key, original[key]);
    }
    return obj
  }

  /**
   * Shallow equal.
   * @param {} objA
   * @param {*} objB
   */
  function equals (objA, objB, deep) {
    if ( deep === void 0 ) deep = false;

    if (objA === objB) {
      return true
    }
    if (!objA || !objB) {
      return false
    }
    if (typeof objA !== 'object' && typeof objB !== 'object') {
      // Compare scalar values
      return objA === objB
    }
    var aKeys = Object.keys(objA);
    var bKeys = Object.keys(objB);
    var len = aKeys.length;

    if (bKeys.length !== len) {
      return false
    }

    for (var i = 0; i < len; i++) {
      var key = aKeys[i];
      if ((!deep && objA[key] !== objB[key]) || (deep && !equals(objA[key], objB[key], deep))) {
        return false
      }
    }
    return true
  }

  /**
   * Given a string, convert snake_case to camelCase
   * @param {String} string
   */
  function camel (string) {
    if (typeof string === 'string') {
      return string.replace(/([_-][a-z0-9])/ig, function ($1) {
        if (string.indexOf($1) !== 0 && !/[_-]/.test(string[string.indexOf($1) - 1])) {
          return $1.toUpperCase().replace(/[_-]/, '')
        }
        return $1
      })
    }
    return string
  }

  /**
   * Given a string, capitalize it. happyDay => HappyDay
   * @param {string} str
   */
  function cap (str) {
    return typeof str === 'string' ? str[0].toUpperCase() + str.substr(1) : str
  }

  /**
   * Given a string, object, falsey, or array - return an array.
   * @param {mixed} item
   */
  function arrayify (item) {
    if (!item) {
      return []
    }
    if (typeof item === 'string') {
      return [item]
    }
    if (Array.isArray(item)) {
      return item
    }
    if (typeof item === 'object') {
      return Object.values(item)
    }
    return []
  }

  /**
   * Given an array or string return an array of callables.
   * @param {array|string} validation
   * @param {array} rules and array of functions
   * @return {array} an array of functions
   */
  function parseRules (validation, rules) {
    if (typeof validation === 'string') {
      return parseRules(validation.split('|'), rules)
    }
    if (!Array.isArray(validation)) {
      return []
    }
    return validation.map(function (rule) { return parseRule(rule, rules); }).filter(function (f) { return !!f; })
  }

  /**
   * Given a string or function, parse it and return an array in the format
   * [fn, [...arguments]]
   * @param {string|function} rule
   */
  function parseRule (rule, rules) {
    if (typeof rule === 'function') {
      return [rule, []]
    }
    if (Array.isArray(rule) && rule.length) {
      rule = rule.map(function (r) { return r; }); // light clone
      var ref = parseModifier(rule.shift());
      var ruleName = ref[0];
      var modifier = ref[1];
      if (typeof ruleName === 'string' && rules.hasOwnProperty(ruleName)) {
        return [rules[ruleName], rule, ruleName, modifier]
      }
      if (typeof ruleName === 'function') {
        return [ruleName, rule, ruleName, modifier]
      }
    }
    if (typeof rule === 'string' && rule) {
      var segments = rule.split(':');
      var ref$1 = parseModifier(segments.shift());
      var ruleName$1 = ref$1[0];
      var modifier$1 = ref$1[1];
      if (rules.hasOwnProperty(ruleName$1)) {
        return [rules[ruleName$1], segments.length ? segments.join(':').split(',') : [], ruleName$1, modifier$1]
      } else {
        throw new Error(("Unknown validation rule " + rule))
      }
    }
    return false
  }

  /**
   * Return the rule name with the applicable modifier as an array.
   * @param {string} ruleName
   * @return {array} [ruleName, modifier]
   */
  function parseModifier (ruleName) {
    if (/^[\^]/.test(ruleName.charAt(0))) {
      return [camel(ruleName.substr(1)), ruleName.charAt(0)]
    }
    return [camel(ruleName), null]
  }

  /**
   * Given an array of rules, group them by bail signals. For example for this:
   * bail|required|min:10|max:20
   * we would expect:
   * [[required], [min], [max]]
   * because any sub-array failure would cause a shutdown. While
   * ^required|min:10|max:10
   * would return:
   * [[required], [min, max]]
   * and no bailing would produce:
   * [[required, min, max]]
   * @param {array} rules
   */
  function groupBails (rules) {
    var groups = [];
    var bailIndex = rules.findIndex(function (ref) {
      var rule = ref[2];

      return rule.toLowerCase() === 'bail';
    });
    var optionalIndex = rules.findIndex(function (ref) {
      var rule = ref[2];

      return rule.toLowerCase() === 'optional';
    });
    if (optionalIndex >= 0) {
      var rule = rules.splice(optionalIndex, 1);
      groups.push(Object.defineProperty(rule, 'bail', { value: true }));
    }
    if (bailIndex >= 0) {
      // Get all the rules until the first bail rule (dont include the bail)
      var preBail = rules.splice(0, bailIndex + 1).slice(0, -1);
      // Rules before the `bail` rule are non-bailing
      preBail.length && groups.push(preBail);
      // All remaining rules are bailing rule groups
      rules.map(function (rule) { return groups.push(Object.defineProperty([rule], 'bail', { value: true })); });
    } else {
      groups.push(rules);
    }

    return groups.reduce(function (groups, group) {
      // Recursively split rules into groups based on the modifiers.
      var splitByMod = function (group, bailGroup) {
        if ( bailGroup === void 0 ) bailGroup = false;

        if (group.length < 2) {
          return Object.defineProperty([group], 'bail', { value: bailGroup })
        }
        var splits = [];
        var modIndex = group.findIndex(function (ref) {
          var modifier = ref[3];

          return modifier === '^';
        });
        if (modIndex >= 0) {
          var preMod = group.splice(0, modIndex);
          // rules before the modifier are non-bailing rules.
          preMod.length && splits.push.apply(splits, splitByMod(preMod, bailGroup));
          splits.push(Object.defineProperty([group.shift()], 'bail', { value: true }));
          // rules after the modifier are non-bailing rules.
          group.length && splits.push.apply(splits, splitByMod(group, bailGroup));
        } else {
          splits.push(group);
        }
        return splits
      };
      return groups.concat(splitByMod(group))
    }, [])
  }

  /**
   * Escape a string for use in regular expressions.
   * @param {string} string
   */
  function escapeRegExp (string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // $& means the whole matched string
  }

  /**
   * Given a string format (date) return a regex to match against.
   * @param {string} format
   */
  function regexForFormat (format) {
    var escaped = "^" + (escapeRegExp(format)) + "$";
    var formats = {
      MM: '(0[1-9]|1[012])',
      M: '([1-9]|1[012])',
      DD: '([012][0-9]|3[01])',
      D: '([012]?[0-9]|3[01])',
      YYYY: '\\d{4}',
      YY: '\\d{2}'
    };
    return new RegExp(Object.keys(formats).reduce(function (regex, format) {
      return regex.replace(format, formats[format])
    }, escaped))
  }

  /**
   * Given a locale string, parse the options.
   * @param {string} locale
   */
  function parseLocale (locale) {
    var segments = locale.split('-');
    return segments.reduce(function (options, segment) {
      if (options.length) {
        options.unshift(((options[0]) + "-" + segment));
      }
      return options.length ? options : [segment]
    }, [])
  }

  /**
   * Shorthand for Object.prototype.hasOwnProperty.call (space saving)
   */
  function has$1 (ctx, prop) {
    return Object.prototype.hasOwnProperty.call(ctx, prop)
  }

  /**
   * Set a unique Symbol identifier on an object.
   * @param {object} o
   * @param {Symbol} id
   */
  function setId (o, id) {
    if (!has$1(o, '__id') || id) {
      return Object.defineProperty(o, '__id', Object.assign(Object.create(null), { value: id || token(9) }))
    }
    return o
  }

  /**
   * Determines if a given value is considered "empty"
   * @param {any} value
   */
  function isEmpty (value) {
    if (typeof value === 'number') {
      return false
    }
    return (
      value === undefined ||
      value === '' ||
      value === null ||
      value === false ||
      (
        Array.isArray(value) && !value.some(function (v) { return !isEmpty(v); })
      ) ||
      (
        (value && !Array.isArray(value) && typeof value === 'object' && isEmpty(Object.values(value)))
      )
    )
  }

  /**
   * Extract a set of attributes.
   * @param {object} obj object to extract from
   * @param {array} array of keys to extract
   */
  function extractAttributes (obj, keys) {
    return Object.keys(obj).reduce(function (props, key) {
      var propKey = camel(key);
      if (keys.includes(propKey)) {
        props[propKey] = obj[key];
      }
      return props
    }, {})
  }

  /**
   * Create a hash of a given string.
   * Credit: https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript#answer-52171480
   *
   * @param {string} str
   * @param {int} seed
   */
  function cyrb43 (str, seed) {
    if ( seed === void 0 ) seed = 0;

    var h1 = 0xdeadbeef ^ seed;
    var h2 = 0x41c6ce57 ^ seed;
    for (var i = 0, ch = (void 0); i < str.length; i++) {
      ch = str.charCodeAt(i);
      h1 = Math.imul(h1 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0)
  }
  /**
   * Create a new debouncer — will debounce any function calls.
   */
  function createDebouncer () {
    var timeout;
    return function debounceFn (fn, args, delay) {
      var this$1$1 = this;

      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(function () { return fn.call.apply(fn, [ this$1$1 ].concat( args )); }, delay);
    }
  }

  /**
   * Creates a unique id of a given length.
   * @param {number} length
   * @returns
   */
  function token (length) {
    if ( length === void 0 ) length = 13;

    return Math.random().toString(36).substring(2, length + 2)
  }

  var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;

  var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
  var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;

  /**
   * Loosely validate a URL `string`.
   *
   * Credit: https://github.com/segmentio/is-url
   *
   * @param {String} string
   * @return {Boolean}
   */

  function isUrl (string) {
    if (typeof string !== 'string') {
      return false
    }

    var match = string.match(protocolAndDomainRE);
    if (!match) {
      return false
    }

    var everythingAfterProtocol = match[1];
    if (!everythingAfterProtocol) {
      return false
    }

    if (localhostDomainRE.test(everythingAfterProtocol) ||
        nonLocalhostDomainRE.test(everythingAfterProtocol)) {
      return true
    }

    return false
  }

  /**
   * The file upload class holds and represents a file’s upload state durring
   * the upload flow.
   */
  var FileUpload = function FileUpload (input, context, globalOptions) {
    if ( globalOptions === void 0 ) globalOptions = {};

    this.input = input;
    this.fileList = input.files;
    this.files = [];
    this.options = Object.assign({}, {mimes: {}},
      globalOptions);
    this.results = false;
    this.context = context;
    this.dataTransferCheck();
    if (context && context.uploadUrl) {
      this.options.uploadUrl = context.uploadUrl;
    }
    this.uploadPromise = null;
    if (Array.isArray(this.fileList)) {
      this.rehydrateFileList(this.fileList);
    } else {
      this.addFileList(this.fileList);
    }
  };

  /**
   * Given a pre-existing array of files, create a faux FileList.
   * @param {array} items expects an array of objects [{ url: '/uploads/file.pdf' }]
   * @param {string} pathKey the object-key to access the url (defaults to "url")
   */
  FileUpload.prototype.rehydrateFileList = function rehydrateFileList (items) {
      var this$1$1 = this;

    var fauxFileList = items.reduce(function (fileList, item) {
      var key = this$1$1.options ? this$1$1.options.fileUrlKey : 'url';
      var url = item[key];
      var ext = (url && url.lastIndexOf('.') !== -1) ? url.substr(url.lastIndexOf('.') + 1) : false;
      var mime = this$1$1.options.mimes[ext] || false;
      fileList.push(Object.assign({}, item, url ? {
        name: item.name || url.substr((url.lastIndexOf('/') + 1) || 0),
        type: item.type ? item.type : mime,
        previewData: url
      } : {}));
      return fileList
    }, []);
    this.addFileList(fauxFileList);
    this.results = this.mapUUID(items);
  };

  /**
   * Produce an array of files and alert the callback.
   * @param {FileList}
   */
  FileUpload.prototype.addFileList = function addFileList (fileList) {
      var this$1$1 = this;

    var loop = function ( i ) {
      var file = fileList[i];
      var uuid = token();
      var removeFile = function () {
        this.removeFile(uuid);
      };
      this$1$1.files.push({
        progress: false,
        error: false,
        complete: false,
        justFinished: false,
        name: file.name || 'file-upload',
        file: file,
        uuid: uuid,
        path: false,
        removeFile: removeFile.bind(this$1$1),
        previewData: file.previewData || false
      });
    };

      for (var i = 0; i < fileList.length; i++) loop( i );
  };

  /**
   * Check if the file has an.
   */
  FileUpload.prototype.hasUploader = function hasUploader () {
    return !!this.context.uploader
  };

  /**
   * Check if the given uploader is axios instance. This isn't a great way of
   * testing if it is or not, but AFIK there isn't a better way right now:
   *
   * https://github.com/axios/axios/issues/737
   */
  FileUpload.prototype.uploaderIsAxios = function uploaderIsAxios () {
    if (
      this.hasUploader() &&
      typeof this.context.uploader.request === 'function' &&
      typeof this.context.uploader.get === 'function' &&
      typeof this.context.uploader.delete === 'function' &&
      typeof this.context.uploader.post === 'function'
    ) {
      return true
    }
    return false
  };

  /**
   * Get a new uploader function.
   */
  FileUpload.prototype.getUploader = function getUploader () {
      var ref;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
    if (this.uploaderIsAxios()) {
      var formData = new FormData();
      formData.append(this.context.name || 'file', args[0]);
      if (this.context.uploadUrl === false) {
        throw new Error('No uploadURL specified: https://vueformulate.com/guide/inputs/file/#props')
      }
      return this.context.uploader.post(this.context.uploadUrl, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: function (progressEvent) {
          // args[1] here is the upload progress handler function
          args[1](Math.round((progressEvent.loaded * 100) / progressEvent.total));
        }
      })
        .then(function (res) { return res.data; })
        .catch(function (err) { return args[2](err); })
    }
    return (ref = this.context).uploader.apply(ref, args)
  };

  /**
   * Perform the file upload.
   */
  FileUpload.prototype.upload = function upload () {
      var this$1$1 = this;

    // If someone calls upload() when an upload is already in process or there
    // already was an upload completed, chain the upload request to the
    // existing one. Already uploaded files wont re-upload and it ensures any
    // files that were added after the initial list are completed too.
    this.uploadPromise = this.uploadPromise
      ? this.uploadPromise.then(function () { return this$1$1.__performUpload(); })
      : this.__performUpload();
    return this.uploadPromise
  };

  /**
   * Perform the actual upload event. Intended to be a private method that is
   * only called through the upload() function as chaining utility.
   */
  FileUpload.prototype.__performUpload = function __performUpload () {
      var this$1$1 = this;

    return new Promise(function (resolve, reject) {
      if (!this$1$1.hasUploader()) {
        return reject(new Error('No uploader has been defined'))
      }
      Promise.all(this$1$1.files.map(function (file) {
        file.error = false;
        file.complete = !!file.path;
        return file.path ? Promise.resolve(file.path) : this$1$1.getUploader(
          file.file,
          function (progress) {
            file.progress = progress;
            this$1$1.context.rootEmit('file-upload-progress', progress);
            if (progress >= 100) {
              if (!file.complete) {
                file.justFinished = true;
                setTimeout(function () { file.justFinished = false; }, this$1$1.options.uploadJustCompleteDuration);
              }
              file.complete = true;
              this$1$1.context.rootEmit('file-upload-complete', file);
            }
          },
          function (error) {
            file.progress = 0;
            file.error = error;
            file.complete = true;
            this$1$1.context.rootEmit('file-upload-error', error);
            reject(error);
          },
          this$1$1.options
        )
      }))
        .then(function (results) {
          this$1$1.results = this$1$1.mapUUID(results);
          resolve(results);
        })
        .catch(function (err) {
          throw new Error(err)
        });
    })
  };

  /**
   * Remove a file from the uploader (and the file list)
   * @param {string} uuid
   */
  FileUpload.prototype.removeFile = function removeFile (uuid) {
    var originalLength = this.files.length;
    this.files = this.files.filter(function (file) { return file && file.uuid !== uuid; });
    if (Array.isArray(this.results)) {
      this.results = this.results.filter(function (file) { return file && file.__id !== uuid; });
    }
    this.context.performValidation();
    if (window && this.fileList instanceof FileList && this.supportsDataTransfers) {
      var transfer = new DataTransfer();
      this.files.forEach(function (file) { return transfer.items.add(file.file); });
      this.fileList = transfer.files;
      this.input.files = this.fileList;
    } else {
      this.fileList = this.fileList.filter(function (file) { return file && file.__id !== uuid; });
    }
    if (originalLength > this.files.length) {
      this.context.rootEmit('file-removed', this.files);
    }
  };

  /**
   * Given another input element, add the files from that FileList to the
   * input being represented by this FileUpload.
   *
   * @param {HTMLElement} input
   */
  FileUpload.prototype.mergeFileList = function mergeFileList (input) {
    this.addFileList(input.files);
    // Create a new mutable FileList
    if (this.supportsDataTransfers) {
      var transfer = new DataTransfer();
      this.files.forEach(function (file) {
        if (file.file instanceof File) {
          transfer.items.add(file.file);
        }
      });
      this.fileList = transfer.files;
      this.input.files = this.fileList;
      // Reset the merged FileList to empty
      input.files = (new DataTransfer()).files;
    }
    this.context.performValidation();
    this.loadPreviews();
    if (this.context.uploadBehavior !== 'delayed') {
      this.upload();
    }
  };

  /**
   * load image previews for all uploads.
   */
  FileUpload.prototype.loadPreviews = function loadPreviews () {
    this.files.map(function (file) {
      if (!file.previewData && window && window.FileReader && /^image\//.test(file.file.type)) {
        var reader = new FileReader();
        reader.onload = function (e) { return Object.assign(file, { previewData: e.target.result }); };
        reader.readAsDataURL(file.file);
      }
    });
  };

  /**
   * Check if the current browser supports the DataTransfer constructor.
   */
  FileUpload.prototype.dataTransferCheck = function dataTransferCheck () {
    try {
      new DataTransfer(); // eslint-disable-line
      this.supportsDataTransfers = true;
    } catch (err) {
      this.supportsDataTransfers = false;
    }
  };

  /**
   * Get the files.
   */
  FileUpload.prototype.getFiles = function getFiles () {
    return this.files
  };

  /**
   * Run setId on each item of a pre-existing array of items.
   * @param {array} items expects an array of objects [{ url: '/uploads/file.pdf' }]
   */
  FileUpload.prototype.mapUUID = function mapUUID (items) {
      var this$1$1 = this;

    return items.map(function (result, index) {
      this$1$1.files[index].path = result !== undefined ? result : false;
      return result && setId(result, this$1$1.files[index].uuid)
    })
  };

  FileUpload.prototype.toString = function toString () {
    var descriptor = this.files.length ? this.files.length + ' files' : 'empty';
    return this.results ? JSON.stringify(this.results, null, '  ') : ("FileUpload(" + descriptor + ")")
  };

  /**
   * Library of rules
   */
  var rules = {
    /**
     * Rule: the value must be "yes", "on", "1", or true
     */
    accepted: function (ref) {
      var value = ref.value;

      return Promise.resolve(['yes', 'on', '1', 1, true, 'true'].includes(value))
    },

    /**
     * Rule: checks if a value is after a given date. Defaults to current time
     */
    after: function (ref, compare) {
      var value = ref.value;
      if ( compare === void 0 ) compare = false;

      var timestamp = Date.parse(compare || new Date());
      var fieldValue = Date.parse(value);
      return Promise.resolve(isNaN(fieldValue) ? false : (fieldValue > timestamp))
    },

    /**
     * Rule: checks if the value is only alpha
     */
    alpha: function (ref, set) {
      var value = ref.value;
      if ( set === void 0 ) set = 'default';

      var sets = {
        default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
        latin: /^[a-zA-Z]+$/
      };
      var selectedSet = sets.hasOwnProperty(set) ? set : 'default';
      return Promise.resolve(sets[selectedSet].test(value))
    },

    /**
     * Rule: checks if the value is alpha numeric
     */
    alphanumeric: function (ref, set) {
      var value = ref.value;
      if ( set === void 0 ) set = 'default';

      var sets = {
        default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
        latin: /^[a-zA-Z0-9]+$/
      };
      var selectedSet = sets.hasOwnProperty(set) ? set : 'default';
      return Promise.resolve(sets[selectedSet].test(value))
    },

    /**
     * Rule: checks if a value is after a given date. Defaults to current time
     */
    before: function (ref, compare) {
      var value = ref.value;
      if ( compare === void 0 ) compare = false;

      var timestamp = Date.parse(compare || new Date());
      var fieldValue = Date.parse(value);
      return Promise.resolve(isNaN(fieldValue) ? false : (fieldValue < timestamp))
    },

    /**
     * Rule: checks if the value is between two other values
     */
    between: function (ref, from, to, force) {
      var value = ref.value;
      if ( from === void 0 ) from = 0;
      if ( to === void 0 ) to = 10;

      return Promise.resolve((function () {
        if (from === null || to === null || isNaN(from) || isNaN(to)) {
          return false
        }
        if ((!isNaN(value) && force !== 'length') || force === 'value') {
          value = Number(value);
          from = Number(from);
          to = Number(to);
          return (value > from && value < to)
        }
        if (typeof value === 'string' || force === 'length') {
          value = !isNaN(value) ? value.toString() : value;
          return value.length > from && value.length < to
        }
        return false
      })())
    },

    /**
     * Confirm that the value of one field is the same as another, mostly used
     * for password confirmations.
     */
    confirm: function (ref, field) {
      var value = ref.value;
      var getGroupValues = ref.getGroupValues;
      var name = ref.name;

      return Promise.resolve((function () {
        var values = getGroupValues();
        var confirmationFieldName = field;
        if (!confirmationFieldName) {
          confirmationFieldName = /_confirm$/.test(name) ? name.substr(0, name.length - 8) : (name + "_confirm");
        }
        return values[confirmationFieldName] === value
      })())
    },

    /**
     * Rule: ensures the value is a date according to Date.parse(), or a format
     * regex.
     */
    date: function (ref, format) {
      var value = ref.value;
      if ( format === void 0 ) format = false;

      return Promise.resolve((function () {
        if (format && typeof format === 'string') {
          return regexForFormat(format).test(value)
        }
        return !isNaN(Date.parse(value))
      })())
    },

    /**
     * Rule: tests
     */
    email: function (ref) {
      var value = ref.value;

      // eslint-disable-next-line
      var isEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
      return Promise.resolve(isEmail.test(value))
    },

    /**
     * Rule: Value ends with one of the given Strings
     */
    endsWith: function (ref) {
      var value = ref.value;
      var stack = [], len = arguments.length - 1;
      while ( len-- > 0 ) stack[ len ] = arguments[ len + 1 ];

      return Promise.resolve((function () {
        if (typeof value === 'string' && stack.length) {
          return stack.find(function (item) {
            return value.endsWith(item)
          }) !== undefined
        } else if (typeof value === 'string' && stack.length === 0) {
          return true
        }
        return false
      })())
    },

    /**
     * Rule: Value is in an array (stack).
     */
    in: function (ref) {
      var value = ref.value;
      var stack = [], len = arguments.length - 1;
      while ( len-- > 0 ) stack[ len ] = arguments[ len + 1 ];

      return Promise.resolve(stack.find(function (item) {
        if (typeof item === 'object') {
          return equals(item, value)
        }
        return item === value
      }) !== undefined)
    },

    /**
     * Rule: Match the value against a (stack) of patterns or strings
     */
    matches: function (ref) {
      var value = ref.value;
      var stack = [], len = arguments.length - 1;
      while ( len-- > 0 ) stack[ len ] = arguments[ len + 1 ];

      return Promise.resolve(!!stack.find(function (pattern) {
        if (typeof pattern === 'string' && pattern.substr(0, 1) === '/' && pattern.substr(-1) === '/') {
          pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        }
        if (pattern instanceof RegExp) {
          return pattern.test(value)
        }
        return pattern === value
      }))
    },

    /**
     * Check the file type is correct.
     */
    mime: function (ref) {
      var value = ref.value;
      var types = [], len = arguments.length - 1;
      while ( len-- > 0 ) types[ len ] = arguments[ len + 1 ];

      return Promise.resolve((function () {
        if (value instanceof FileUpload) {
          var fileList = value.getFiles();
          for (var i = 0; i < fileList.length; i++) {
            var file = fileList[i].file;
            if (!types.includes(file.type)) {
              return false
            }
          }
        }
        return true
      })())
    },

    /**
     * Check the minimum value of a particular.
     */
    min: function (ref, minimum, force) {
      var value = ref.value;
      if ( minimum === void 0 ) minimum = 1;

      return Promise.resolve((function () {
        if (Array.isArray(value)) {
          minimum = !isNaN(minimum) ? Number(minimum) : minimum;
          return value.length >= minimum
        }
        if ((!isNaN(value) && force !== 'length') || force === 'value') {
          value = !isNaN(value) ? Number(value) : value;
          return value >= minimum
        }
        if (typeof value === 'string' || (force === 'length')) {
          value = !isNaN(value) ? value.toString() : value;
          return value.length >= minimum
        }
        return false
      })())
    },

    /**
     * Check the maximum value of a particular.
     */
    max: function (ref, maximum, force) {
      var value = ref.value;
      if ( maximum === void 0 ) maximum = 10;

      return Promise.resolve((function () {
        if (Array.isArray(value)) {
          maximum = !isNaN(maximum) ? Number(maximum) : maximum;
          return value.length <= maximum
        }
        if ((!isNaN(value) && force !== 'length') || force === 'value') {
          value = !isNaN(value) ? Number(value) : value;
          return value <= maximum
        }
        if (typeof value === 'string' || (force === 'length')) {
          value = !isNaN(value) ? value.toString() : value;
          return value.length <= maximum
        }
        return false
      })())
    },

    /**
     * Rule: Value is not in stack.
     */
    not: function (ref) {
      var value = ref.value;
      var stack = [], len = arguments.length - 1;
      while ( len-- > 0 ) stack[ len ] = arguments[ len + 1 ];

      return Promise.resolve(stack.find(function (item) {
        if (typeof item === 'object') {
          return equals(item, value)
        }
        return item === value
      }) === undefined)
    },

    /**
     * Rule: checks if the value is only alpha numeric
     */
    number: function (ref) {
      var value = ref.value;

      return Promise.resolve(!isNaN(value))
    },

    /**
     * Rule: must be a value - allows for an optional argument "whitespace" with a possible value 'trim' and default 'pre'.
     */
    required: function (ref, whitespace) {
      var value = ref.value;
      if ( whitespace === void 0 ) whitespace = 'pre';

      return Promise.resolve((function () {
        if (Array.isArray(value)) {
          return !!value.length
        }
        if (value instanceof FileUpload) {
          return value.getFiles().length > 0
        }
        if (typeof value === 'string') {
          return whitespace === 'trim' ? !!value.trim() : !!value
        }
        if (typeof value === 'object') {
          return (!value) ? false : !!Object.keys(value).length
        }
        return true
      })())
    },

    /**
     * Rule: Value starts with one of the given Strings
     */
    startsWith: function (ref) {
      var value = ref.value;
      var stack = [], len = arguments.length - 1;
      while ( len-- > 0 ) stack[ len ] = arguments[ len + 1 ];

      return Promise.resolve((function () {
        if (typeof value === 'string' && stack.length) {
          return stack.find(function (item) {
            return value.startsWith(item)
          }) !== undefined
        } else if (typeof value === 'string' && stack.length === 0) {
          return true
        }
        return false
      })())
    },

    /**
     * Rule: checks if a string is a valid url
     */
    url: function (ref) {
      var value = ref.value;

      return Promise.resolve(isUrl(value))
    },

    /**
     * Rule: not a true rule — more like a compiler flag.
     */
    bail: function () {
      return Promise.resolve(true)
    },

    /**
     * Rule: not a true rule - more like a compiler flag.
     */
    optional: function (ref) {
      var value = ref.value;

      // So technically we "fail" this rule anytime the field is empty. This rule
      // is automatically hoisted to the top of the validation stack, and marked
      // as a "bail" rule, meaning if it fails, no further validation will be run.
      // Finally, the error message associated with this rule is filtered out.
      return Promise.resolve(!isEmpty(value))
    }
  };

  var i = 'image/';
  var mimes = {
    'csv': 'text/csv',
    'gif': i + 'gif',
    'jpg': i + 'jpeg',
    'jpeg': i + 'jpeg',
    'png': i + 'png',
    'pdf': 'application/pdf',
    'svg': i + 'svg+xml'
  };

  /**
   * A list of available class keys in core. These can be added to by extending
   * the `classKeys` global option when registering formulate.
   */
  var classKeys = [
    // Globals
    'outer',
    'wrapper',
    'label',
    'element',
    'input',
    'help',
    'errors',
    'error',
    // Box
    'decorator',
    // Slider
    'rangeValue',
    // File
    'uploadArea',
    'uploadAreaMask',
    'files',
    'file',
    'fileName',
    'fileAdd',
    'fileAddInput',
    'fileRemove',
    'fileProgress',
    'fileUploadError',
    'fileImagePreview',
    'fileImagePreviewImage',
    'fileProgressInner',
    // Groups
    'grouping',
    'groupRepeatable',
    'groupRepeatableRemove',
    'groupAddMore',
    // Forms
    'form',
    'formErrors',
    'formError'
  ];

  /**
   * State keys by default
   */
  var states = {
    hasErrors: function (c) { return c.hasErrors; },
    hasValue: function (c) { return c.hasValue; },
    isValid: function (c) { return c.isValid; }
  };

  /**
   * This function is responsible for providing VueFormulate’s default classes.
   * This function is called with the specific classKey ('wrapper' for example)
   * that it needs to generate classes for, and the context object. It always
   * returns an array.
   *
   * @param {string} classKey
   * @param {Object} context
   */
  var classGenerator = function (classKey, context) {
    // camelCase to dash-case
    var key = classKey.replace(/[A-Z]/g, function (c) { return '-' + c.toLowerCase(); });
    var prefix = ['form', 'file'].includes(key.substr(0, 4)) ? '' : '-input';
    var element = ['decorator', 'range-value'].includes(key) ? '-element' : '';
    var base = "formulate" + prefix + element + (key !== 'outer' ? ("-" + key) : '');
    return key === 'input' ? [] : [base].concat(classModifiers(base, classKey, context))
  };

  /**
   * Given a class key and a modifier, produce any additional classes.
   * @param {string} classKey
   * @param {Object} context
   */
  var classModifiers = function (base, classKey, context) {
    var modifiers = [];
    switch (classKey) {
      case 'label':
        modifiers.push((base + "--" + (context.labelPosition)));
        break
      case 'element':
        var type = context.classification === 'group' ? 'group' : context.type;
        modifiers.push((base + "--" + type));
        // @todo DEPRECATED! This should be removed in a future version:
        if (type === 'group') {
          modifiers.push('formulate-input-group');
        }
        break
      case 'help':
        modifiers.push((base + "--" + (context.helpPosition)));
        break
      case 'form':
        if (context.name) {
          modifiers.push((base + "--" + (context.name)));
        }
    }
    return modifiers
  };

  /**
   * Generate a list of all the class props to accept.
   */
  var classProps = (function () {
    var stateKeys = [''].concat(Object.keys(states).map(function (s) { return cap(s); }));
    // This reducer produces a key for every element key + state key variation
    return classKeys.reduce(function (props, classKey) {
      return props.concat(stateKeys.reduce(function (keys, stateKey) {
        keys.push(("" + classKey + stateKey + "Class"));
        return keys
      }, []))
    }, [])
  })();

  /**
   * Given a string or array of classes and a modifier (function, string etc) apply
   * the modifications.
   *
   * @param {mixed} baseClass The initial class for a given key
   * @param {mixed} modifier A function, string, array etc that can be a class prop.
   * @param {Object} context The class context
   */
  function applyClasses (baseClass, modifier, context) {
    switch (typeof modifier) {
      case 'string':
        return modifier
      case 'function':
        return modifier(context, arrayify(baseClass))
      case 'object':
        if (Array.isArray(modifier)) {
          return arrayify(baseClass).concat(modifier)
        }
      /** allow fallthrough if object that isn’t an array */
      default:
        return baseClass
    }
  }

  /**
   * Given element class key
   * @param {string} elementKey the element class key we're generating for
   * @param {mixed} baseClass The initial classes for this key
   * @param {object} global Class definitions globally registered with options.classes
   * @param {Object} context Class context for this particular field, props included.
   */
  function applyStates (elementKey, baseClass, globals, context) {
    return Object.keys(states).reduce(function (classes, stateKey) {
      // Step 1. Call the state function to determine if it has this state
      if (states[stateKey](context)) {
        var key = "" + elementKey + (cap(stateKey));
        var propKey = key + "Class";
        // Step 2. Apply any global state class keys
        if (globals[key]) {
          var modifier = (typeof globals[key] === 'string') ? arrayify(globals[key]) : globals[key];
          classes = applyClasses(classes, modifier, context);
        }
        // Step 3. Apply any prop state class keys
        if (context[propKey]) {
          var modifier$1 = (typeof context[propKey] === 'string') ? arrayify(context[propKey]) : context[(key + "Class")];
          classes = applyClasses(classes, modifier$1, context);
        }
      }
      return classes
    }, baseClass)
  }

  /**
   * Function that produces all available classes.
   * @param {Object} context
   */
  function coreClasses (context) {
    return classKeys.reduce(function (classes, classKey) {
      var obj;

      return Object.assign(classes, ( obj = {}, obj[classKey] = classGenerator(classKey, context), obj ));
    }, {})
  }

  /**
   * A fake uploader used by default.
   *
   * @param {File} file
   * @param {function} progress
   * @param {function} error
   * @param {object} options
   */
  function fauxUploader (file, progress, error, options) {
    return new Promise(function (resolve, reject) {
      var totalTime = (options.fauxUploaderDuration || 1500) * (0.5 + Math.random());
      var start = performance.now();

      /**
       * Create a recursive timeout that advances the progress.
       */
      var advance = function () { return setTimeout(function () {
        var elapsed = performance.now() - start;
        var currentProgress = Math.min(100, Math.round(elapsed / totalTime * 100));
        progress(currentProgress);

        if (currentProgress >= 100) {
          return resolve({
            url: 'http://via.placeholder.com/350x150.png',
            name: file.name
          })
        } else {
          advance();
        }
      }, 20); };
      advance();
    })
  }

  function objectWithoutProperties$5 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
  var FormulateSlot = {
    inheritAttrs: false,
    functional: true,
    render: function render (h, ref) {
      var props = ref.props;
      var data = ref.data;
      var parent = ref.parent;
      var children = ref.children;

      var p = parent;
      props.name;
      var forceWrap = props.forceWrap;
      var context = props.context;
      var rest = objectWithoutProperties$5( props, ["name", "forceWrap", "context"] );
      var mergeWithContext = rest;

      // Look up the ancestor tree for the first FormulateInput
      while (p && p.$options.name !== 'FormulateInput') {
        p = p.$parent;
      }

      // if we never found the proper parent, just end it.
      if (!p) {
        return null
      }

      // If we found a formulate input, check for a matching scoped slot
      if (p.$scopedSlots && p.$scopedSlots[props.name]) {
        return p.$scopedSlots[props.name](Object.assign({}, context, mergeWithContext))
      }

      // If we found no scoped slot, take the children and render those inside a wrapper if there are multiple
      if (Array.isArray(children) && (children.length > 1 || (forceWrap && children.length > 0))) {
        var ref$1 = data.attrs;
        ref$1.name;
        ref$1.context;
        var rest = objectWithoutProperties$5( ref$1, ["name", "context"] );
        var attrs = rest;
        return h('div', Object.assign({}, data, {attrs: attrs}), children)

      // If there is only one child, render it alone
      } else if (Array.isArray(children) && children.length === 1) {
        return children[0]
      }

      // If there are no children, render nothing
      return null
    }
  };

  function objectWithoutProperties$4 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  /**
   * Given an object and an index, complete an object for schema-generation.
   * @param {object} item
   * @param {int} index
   */
  function leaf (item, index, rootListeners) {
    if ( index === void 0 ) index = 0;
    if ( rootListeners === void 0 ) rootListeners = {};

    if (item && typeof item === 'object' && !Array.isArray(item)) {
      var children = item.children; if ( children === void 0 ) children = null;
      var component = item.component; if ( component === void 0 ) component = 'FormulateInput';
      var depth = item.depth; if ( depth === void 0 ) depth = 1;
      var key = item.key; if ( key === void 0 ) key = null;
      var rest = objectWithoutProperties$4( item, ["children", "component", "depth", "key"] );
      var attrs = rest;
      // these next two lines are required since `class` is a keyword and should
      // not be used in rest/spread operators.
      var cls = attrs.class || {};
      delete attrs.class;
      // Event bindings
      var on = {};

      // Extract events from this instance
      var events = Object.keys(attrs)
        .reduce(function (events, key) {
          var obj;

          return /^@/.test(key) ? Object.assign(events, ( obj = {}, obj[key.substr(1)] = attrs[key], obj )) : events;
      }, {});

      // delete all events from the item
      Object.keys(events).forEach(function (event) {
        delete attrs[("@" + event)];
        on[event] = createListener(event, events[event], rootListeners);
      });

      var type = component === 'FormulateInput' ? (attrs.type || 'text') : component;
      var name = attrs.name || type || 'el';
      if (!key) {
        // We need to generate a unique key if at all possible
        if (attrs.id) {
          // We've been given an id, so we should use it.
          key = attrs.id;
        } else if (component !== 'FormulateInput' && typeof children === 'string') {
          // This is a simple text node container.
          key = type + "-" + (cyrb43(children));
        } else {
          // This is a wrapper element
          key = type + "-" + name + "-" + depth + (attrs.name ? '' : '-' + index);
        }
      }
      var els = Array.isArray(children)
        ? children.map(function (child) { return Object.assign(child, { depth: depth + 1 }); })
        : children;
      return Object.assign({ key: key, depth: depth, attrs: attrs, component: component, class: cls, on: on }, els ? { children: els } : {})
    }
    return null
  }

  /**
   * Recursive function to create vNodes from a schema.
   * @param {Functon} h createElement
   * @param {Array|string} schema
   */
  function tree (h, schema, rootListeners) {
    if (Array.isArray(schema)) {
      return schema.map(function (el, index) {
        var item = leaf(el, index, rootListeners);
        return h(
          item.component,
          { attrs: item.attrs, class: item.class, key: item.key, on: item.on },
          item.children ? tree(h, item.children, rootListeners) : null
        )
      })
    }
    return schema
  }

  /**
   * Given an event name and handler, return a handler function that re-emits.
   *
   * @param {string} event
   * @param {string|boolean|function} handler
   */
  function createListener (eventName, handler, rootListeners) {
    return function () {
      var ref, ref$1;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
      // For event leafs like { '@blur': function () { ..do things... } }
      if (typeof handler === 'function') {
        return handler.call.apply(handler, [ this ].concat( args ))
      }
      // For event leafs like { '@blur': 'nameBlur' }
      if (typeof handler === 'string' && has$1(rootListeners, handler)) {
        return (ref = rootListeners[handler]).call.apply(ref, [ this ].concat( args ))
      }
      // For event leafs like { '@blur': true }
      if (has$1(rootListeners, eventName)) {
        return (ref$1 = rootListeners[eventName]).call.apply(ref$1, [ this ].concat( args ))
      }
    }
  }

  var FormulateSchema = {
    functional: true,
    render: function (h, ref) {
      var props = ref.props;
      var listeners = ref.listeners;

      return tree(h, props.schema, listeners);
  }
  };

  function objectWithoutProperties$3 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  /**
   * Component registry with inherent depth to handle complex nesting. This is
   * important for features such as grouped fields.
   */
  var Registry = function Registry (ctx) {
    this.registry = new Map();
    this.errors = {};
    this.ctx = ctx;
  };

  /**
   * Add an item to the registry.
   * @param {string|array} key
   * @param {vue} component
   */
  Registry.prototype.add = function add (name, component) {
      var obj;

    this.registry.set(name, component);
    this.errors = Object.assign({}, this.errors, ( obj = {}, obj[name] = component.getErrorObject().hasErrors, obj ));
    return this
  };

  /**
   * Remove an item from the registry.
   * @param {string} name
   */
  Registry.prototype.remove = function remove (name) {
    // Clean up dependent validations
    this.ctx.deps.delete(this.registry.get(name));
    this.ctx.deps.forEach(function (dependents) { return dependents.delete(name); });

    // Determine if we're keep the model data or destroying it
    var keepData = this.ctx.keepModelData;
    if (!keepData && this.registry.has(name) && this.registry.get(name).keepModelData !== 'inherit') {
      keepData = this.registry.get(name).keepModelData;
    }
    if (this.ctx.preventCleanup) {
      keepData = true;
    }

    this.registry.delete(name);
    var ref = this.errors;
      ref[name];
      var rest = objectWithoutProperties$3( ref, [String(name)] );
      var errorValues = rest;
    this.errors = errorValues;

    // Clean up the model if we don't explicitly state otherwise
    if (!keepData) {
      var ref$1 = this.ctx.proxy;
        ref$1[name];
        var rest = objectWithoutProperties$3( ref$1, [String(name)] );
        var newProxy = rest;
      if (this.ctx.uuid) {
        // If the registry context has a uuid (row.__id) be sure to include it in
        // this input event so it can replace values in the proper row.
        setId(newProxy, this.ctx.uuid);
      }
      this.ctx.proxy = newProxy;
      this.ctx.$emit('input', this.ctx.proxy);
    }
    return this
  };

  /**
   * Check if the registry has the given key.
   * @param {string|array} key
   */
  Registry.prototype.has = function has (key) {
    return this.registry.has(key)
  };

  /**
   * Get a particular registry value.
   * @param {string} key
   */
  Registry.prototype.get = function get (key) {
    return this.registry.get(key)
  };

  /**
   * Map over the registry (recursively).
   * @param {function} callback
   */
  Registry.prototype.map = function map (callback) {
    var value = {};
    this.registry.forEach(function (component, field) {
        var obj;

        return Object.assign(value, ( obj = {}, obj[field] = callback(component, field), obj ));
      });
    return value
  };

  /**
   * Return the keys of the registry.
   */
  Registry.prototype.keys = function keys () {
    return Array.from(this.registry.keys())
  };

  /**
   * Fully register a component.
   * @param {string} field name of the field.
   * @param {vm} component the actual component instance.
   */
  Registry.prototype.register = function register (field, component) {
      var this$1$1 = this;

    if (has$1(component.$options.propsData, 'ignored')) {
      // Any presence of the `ignored` prop will ensure this input is skipped.
      return false
    }
    if (this.registry.has(field)) {
      // Here we check to see if the field we are about to register is going to
      // immediately be removed. That indicates this field is switching like in
      // a v-if:
      //
      // <FormulateInput name="foo" v-if="condition" />
      // <FormulateInput name="foo" v-else />
      //
      // Because created() fires _before_ destroyed() the new field would not
      // register because the old one would not have yet unregistered. By
      // checking if field we're trying to register is gone on the nextTick we
      // can assume it was supposed to register, and do so "again".
      this.ctx.$nextTick(function () { return !this$1$1.registry.has(field) ? this$1$1.register(field, component) : false; });
      return false
    }
    this.add(field, component);
    var hasVModelValue = has$1(component.$options.propsData, 'formulateValue');
    var hasValue = has$1(component.$options.propsData, 'value');
    // This is not reactive
    var debounceDelay = this.ctx.debounce || this.ctx.debounceDelay || (this.ctx.context && this.ctx.context.debounceDelay);
    if (debounceDelay && !has$1(component.$options.propsData, 'debounce')) {
      component.debounceDelay = debounceDelay;
    }
    if (
      !hasVModelValue &&
      this.ctx.hasInitialValue &&
      !isEmpty(this.ctx.initialValues[field])
    ) {
      // In the case that the form is carrying an initial value and the
      // element is not, set it directly.
      component.context.model = this.ctx.initialValues[field];
    } else if (
      (hasVModelValue || hasValue) &&
      !equals(component.proxy, this.ctx.initialValues[field], true)
    ) {
      // In this case, the field is v-modeled or has an initial value and the
      // registry has no value or a different value, so use the field value
      this.ctx.setFieldValue(field, component.proxy);
    }
    if (this.childrenShouldShowErrors) {
      component.formShouldShowErrors = true;
    }
  };

  /**
   * Reduce the registry.
   * @param {function} callback
   */
  Registry.prototype.reduce = function reduce (callback, accumulator) {
    this.registry.forEach(function (component, field) {
      accumulator = callback(accumulator, component, field);
    });
    return accumulator
  };

  /**
   * Data props to expose.
   */
  Registry.prototype.dataProps = function dataProps () {
      var this$1$1 = this;

    return {
      proxy: {},
      registry: this,
      register: this.register.bind(this),
      deregister: function (field) { return this$1$1.remove(field); },
      childrenShouldShowErrors: false,
      errorObservers: [],
      deps: new Map(),
      preventCleanup: false
    }
  };

  /**
   * The context component.
   * @param {component} contextComponent
   */
  function useRegistry (contextComponent) {
    var registry = new Registry(contextComponent);
    return registry.dataProps()
  }

  /**
   * Computed properties related to the registry.
   */
  function useRegistryComputed (options) {

    return {
      hasInitialValue: function hasInitialValue () {
        return (
          (this.formulateValue && typeof this.formulateValue === 'object') ||
          (this.values && typeof this.values === 'object') ||
          (this.isGrouping && typeof this.context.model[this.index] === 'object')
        )
      },
      isVmodeled: function isVmodeled () {
        return !!(this.$options.propsData.hasOwnProperty('formulateValue') &&
          this._events &&
          Array.isArray(this._events.input) &&
          this._events.input.length)
      },
      initialValues: function initialValues () {
        if (
          has$1(this.$options.propsData, 'formulateValue') &&
          typeof this.formulateValue === 'object'
        ) {
          // If there is a v-model on the form/group, use those values as first priority
          return Object.assign({}, this.formulateValue) // @todo - use a deep clone to detach reference types?
        } else if (
          has$1(this.$options.propsData, 'values') &&
          typeof this.values === 'object'
        ) {
          // If there are values, use them as secondary priority
          return Object.assign({}, this.values)
        } else if (
          this.isGrouping && typeof this.context.model[this.index] === 'object'
        ) {
          return this.context.model[this.index]
        }
        return {}
      },
      mergedGroupErrors: function mergedGroupErrors () {
        var this$1$1 = this;

        var hasSubFields = /^([^.\d+].*?)\.(\d+\..+)$/;
        return Object.keys(this.mergedFieldErrors)
          .filter(function (k) { return hasSubFields.test(k); })
          .reduce(function (groupErrorsByRoot, k) {
            var obj;

            var ref = k.match(hasSubFields);
            var rootField = ref[1];
            var groupKey = ref[2];
            if (!groupErrorsByRoot[rootField]) {
              groupErrorsByRoot[rootField] = {};
            }
            Object.assign(groupErrorsByRoot[rootField], ( obj = {}, obj[groupKey] = this$1$1.mergedFieldErrors[k], obj ));
            return groupErrorsByRoot
          }, {})
      }
    }
  }

  /**
   * Methods used in the registry.
   */
  function useRegistryMethods (without) {
    if ( without === void 0 ) without = [];

    var methods = {
      applyInitialValues: function applyInitialValues () {
        if (this.hasInitialValue) {
          this.proxy = Object.assign({}, this.initialValues);
        }
      },
      setFieldValue: function setFieldValue (field, value) {
        var obj;

        if (value === undefined) {
          // undefined values should be removed from the form model
          var ref = this.proxy;
          ref[field];
          var rest = objectWithoutProperties$3( ref, [String(field)] );
          var proxy = rest;
          this.proxy = proxy;
        } else {
          Object.assign(this.proxy, ( obj = {}, obj[field] = value, obj ));
        }
        this.$emit('input', Object.assign({}, this.proxy));
      },
      valueDeps: function valueDeps (callerCmp) {
        var this$1$1 = this;

        return Object.keys(this.proxy)
          .reduce(function (o, k) { return Object.defineProperty(o, k, {
            enumerable: true,
            get: function () {
              var callee = this$1$1.registry.get(k);
              this$1$1.deps.set(callerCmp, this$1$1.deps.get(callerCmp) || new Set());
              if (callee) {
                this$1$1.deps.set(callee, this$1$1.deps.get(callee) || new Set());
                this$1$1.deps.get(callee).add(callerCmp.name);
              }
              this$1$1.deps.get(callerCmp).add(k);
              return this$1$1.proxy[k]
            }
          }); }, Object.create(null))
      },
      validateDeps: function validateDeps (callerCmp) {
        var this$1$1 = this;

        if (this.deps.has(callerCmp)) {
          this.deps.get(callerCmp).forEach(function (field) { return this$1$1.registry.has(field) && this$1$1.registry.get(field).performValidation(); });
        }
      },
      hasValidationErrors: function hasValidationErrors () {
        return Promise.all(this.registry.reduce(function (resolvers, cmp, name) {
          resolvers.push(cmp.performValidation() && cmp.getValidationErrors());
          return resolvers
        }, [])).then(function (errorObjects) { return errorObjects.some(function (item) { return item.hasErrors; }); })
      },
      showErrors: function showErrors () {
        this.childrenShouldShowErrors = true;
        this.registry.map(function (input) {
          input.formShouldShowErrors = true;
        });
      },
      hideErrors: function hideErrors () {
        this.childrenShouldShowErrors = false;
        this.registry.map(function (input) {
          input.formShouldShowErrors = false;
          input.behavioralErrorVisibility = false;
        });
      },
      setValues: function setValues (values) {
        var this$1$1 = this;

        // Collect all keys, existing and incoming
        var keys = Array.from(new Set(Object.keys(values || {}).concat(Object.keys(this.proxy))));
        keys.forEach(function (field) {
          var input = this$1$1.registry.has(field) && this$1$1.registry.get(field);
          var value = values ? values[field] : undefined;
          if (input && !equals(input.proxy, value, true)) {
            input.context.model = value;
          }
          if (!equals(value, this$1$1.proxy[field], true)) {
            this$1$1.setFieldValue(field, value);
          }
        });
      },
      updateValidation: function updateValidation (errorObject) {
        if (has$1(this.registry.errors, errorObject.name)) {
          this.registry.errors[errorObject.name] = errorObject.hasErrors;
        }
        this.$emit('validation', errorObject);
      },
      addErrorObserver: function addErrorObserver (observer) {
        if (!this.errorObservers.find(function (obs) { return observer.callback === obs.callback; })) {
          this.errorObservers.push(observer);
          if (observer.type === 'form') {
            observer.callback(this.mergedFormErrors);
          } else if (observer.type === 'group' && has$1(this.mergedGroupErrors, observer.field)) {
            observer.callback(this.mergedGroupErrors[observer.field]);
          } else if (has$1(this.mergedFieldErrors, observer.field)) {
            observer.callback(this.mergedFieldErrors[observer.field]);
          }
        }
      },
      removeErrorObserver: function removeErrorObserver (observer) {
        this.errorObservers = this.errorObservers.filter(function (obs) { return obs.callback !== observer; });
      }
    };
    return Object.keys(methods).reduce(function (withMethods, key) {
      var obj;

      return without.includes(key) ? withMethods : Object.assign({}, withMethods, ( obj = {}, obj[key] = methods[key], obj ))
    }, {})
  }

  /**
   * Unified registry watchers.
   */
  function useRegistryWatchers () {
    return {
      mergedFieldErrors: {
        handler: function handler (errors) {
          this.errorObservers
            .filter(function (o) { return o.type === 'input'; })
            .forEach(function (o) { return o.callback(errors[o.field] || []); });
        },
        immediate: true
      },
      mergedGroupErrors: {
        handler: function handler (errors) {
          this.errorObservers
            .filter(function (o) { return o.type === 'group'; })
            .forEach(function (o) { return o.callback(errors[o.field] || {}); });
        },
        immediate: true
      }
    }
  }

  /**
   * Providers related to the registry.
   */
  function useRegistryProviders (ctx, without) {
    if ( without === void 0 ) without = [];

    var providers = {
      formulateSetter: ctx.setFieldValue,
      formulateRegister: ctx.register,
      formulateDeregister: ctx.deregister,
      formulateFieldValidation: ctx.updateValidation,
      // Provided on forms only to let getFormValues to fall back to form
      getFormValues: ctx.valueDeps,
      // Provided on groups only to expose group-level items
      getGroupValues: ctx.valueDeps,
      validateDependents: ctx.validateDeps,
      observeErrors: ctx.addErrorObserver,
      removeErrorObserver: ctx.removeErrorObserver
    };
    var p = Object.keys(providers)
      .filter(function (provider) { return !without.includes(provider); })
      .reduce(function (useProviders, provider) {
        var obj;

        return Object.assign(useProviders, ( obj = {}, obj[provider] = providers[provider], obj ));
    }, {});
    return p
  }

  /**
   * A simple (somewhat non-comprehensive) cloneDeep function, valid for our use
   * case of needing to unbind reactive watchers.
   */
  function cloneDeep (obj) {
      if (typeof obj !== 'object') {
        return obj
      }
      var isArr = Array.isArray(obj);
      var newObj = isArr ? [] : {};
      for (var key in obj) {
        if (obj[key] instanceof FileUpload || isValueType(obj[key])) {
          newObj[key] = obj[key];
        } else {
          newObj[key] = cloneDeep(obj[key]);
        }
      }
      return newObj
    }

  var FormSubmission = function FormSubmission (form) {
    this.form = form;
  };

  /**
   * Determine if the form has any validation errors.
   *
   * @return {Promise} resolves a boolean
   */
  FormSubmission.prototype.hasValidationErrors = function hasValidationErrors () {
    return this.form.hasValidationErrors()
  };

  /**
   * Asynchronously generate the values payload of this form.
   * @return {Promise} resolves to json
   */
  FormSubmission.prototype.values = function values () {
      var this$1$1 = this;

    return new Promise(function (resolve, reject) {
      var pending = [];
      var values = cloneDeep(this$1$1.form.proxy);
      var loop = function ( key ) {
        if (typeof this$1$1.form.proxy[key] === 'object' && this$1$1.form.proxy[key] instanceof FileUpload) {
          pending.push(
            this$1$1.form.proxy[key].upload().then(function (data) {
                var obj;

                return Object.assign(values, ( obj = {}, obj[key] = data, obj ));
            })
          );
        }
      };

        for (var key in values) loop( key );
      Promise.all(pending)
        .then(function () { return resolve(values); })
        .catch(function (err) { return reject(err); });
    })
  };

  function objectWithoutProperties$2 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  var script$l = {
    name: 'FormulateForm',
    inheritAttrs: false,
    provide: function provide () {
      return Object.assign({}, useRegistryProviders(this, ['getGroupValues']),
        {observeContext: this.addContextObserver,
        removeContextObserver: this.removeContextObserver})
    },
    model: {
      prop: 'formulateValue',
      event: 'input'
    },
    props: {
      name: {
        type: [String, Boolean],
        default: false
      },
      formulateValue: {
        type: Object,
        default: function () { return ({}); }
      },
      values: {
        type: [Object, Boolean],
        default: false
      },
      errors: {
        type: [Object, Boolean],
        default: false
      },
      formErrors: {
        type: Array,
        default: function () { return ([]); }
      },
      schema: {
        type: [Array, Boolean],
        default: false
      },
      keepModelData: {
        type: [Boolean, String],
        default: false
      },
      invalidMessage: {
        type: [Boolean, Function, String],
        default: false
      },
      debounce: {
        type: [Boolean, Number],
        default: false
      }
    },
    data: function data () {
      return Object.assign({}, useRegistry(this),
        {formShouldShowErrors: false,
        contextObservers: [],
        namedErrors: [],
        namedFieldErrors: {},
        isLoading: false,
        hasFailedSubmit: false})
    },
    computed: Object.assign({}, useRegistryComputed(),
      {schemaListeners: function schemaListeners () {
        var ref = this.$listeners;
        ref.submit;
        var rest = objectWithoutProperties$2( ref, ["submit"] );
        var listeners = rest;
        return listeners
      },
      pseudoProps: function pseudoProps () {
        return extractAttributes(this.$attrs, classProps.filter(function (p) { return /^form/.test(p); }))
      },
      attributes: function attributes () {
        var this$1$1 = this;

        var attrs = Object.keys(this.$attrs)
          .filter(function (attr) { return !has$1(this$1$1.pseudoProps, camel(attr)); })
          .reduce(function (fields, field) {
            var obj;

            return (Object.assign({}, fields, ( obj = {}, obj[field] = this$1$1.$attrs[field], obj )));
        }, {}); // Create an object of attributes to re-bind
        if (typeof this.name === 'string') {
          Object.assign(attrs, { name: this.name });
        }
        return attrs
      },
      hasErrors: function hasErrors () {
        return Object.values(this.registry.errors).some(function (hasErrors) { return hasErrors; })
      },
      isValid: function isValid () {
        return !this.hasErrors
      },
      formContext: function formContext () {
        return {
          errors: this.mergedFormErrors,
          pseudoProps: this.pseudoProps,
          hasErrors: this.hasErrors,
          value: this.proxy,
          hasValue: !isEmpty(this.proxy), // These have to be explicit for really silly nextTick reasons
          isValid: this.isValid,
          isLoading: this.isLoading,
          classes: this.classes
        }
      },
      classes: function classes () {
        return this.$formulate.classes(Object.assign({}, this.$props,
          this.pseudoProps,
          {value: this.proxy,
          errors: this.mergedFormErrors,
          hasErrors: this.hasErrors,
          hasValue: !isEmpty(this.proxy),
          isValid: this.isValid,
          isLoading: this.isLoading,
          type: 'form',
          classification: 'form',
          attrs: this.$attrs}))
      },
      invalidErrors: function invalidErrors () {
        if (this.hasFailedSubmit && this.hasErrors) {
          switch (typeof this.invalidMessage) {
            case 'string':
              return [this.invalidMessage]
            case 'object':
              return Array.isArray(this.invalidMessage) ? this.invalidMessage : []
            case 'function':
              var ret = this.invalidMessage(this.failingFields);
              return Array.isArray(ret) ? ret : [ret]
          }
        }
        return []
      },
      mergedFormErrors: function mergedFormErrors () {
        return this.formErrors.concat(this.namedErrors).concat(this.invalidErrors)
      },
      mergedFieldErrors: function mergedFieldErrors () {
        var errors = {};
        if (this.errors) {
          for (var fieldName in this.errors) {
            errors[fieldName] = arrayify(this.errors[fieldName]);
          }
        }
        for (var fieldName$1 in this.namedFieldErrors) {
          errors[fieldName$1] = arrayify(this.namedFieldErrors[fieldName$1]);
        }
        return errors
      },
      hasFormErrorObservers: function hasFormErrorObservers () {
        return !!this.errorObservers.filter(function (o) { return o.type === 'form'; }).length
      },
      failingFields: function failingFields () {
        var this$1$1 = this;

        return Object.keys(this.registry.errors)
          .reduce(function (fields, field) {
            var obj;

            return (Object.assign({}, fields,
            (this$1$1.registry.errors[field] ? ( obj = {}, obj[field] = this$1$1.registry.get(field), obj ) : {})));
        }, {})
      }}),
    watch: Object.assign({}, useRegistryWatchers(),
      {formulateValue: {
        handler: function handler (values) {
          if (this.isVmodeled &&
            values &&
            typeof values === 'object'
          ) {
            this.setValues(values);
          }
        },
        deep: true
      },
      mergedFormErrors: function mergedFormErrors (errors) {
        this.errorObservers
          .filter(function (o) { return o.type === 'form'; })
          .forEach(function (o) { return o.callback(errors); });
      }}),
    created: function created () {
      this.$formulate.register(this);
      this.applyInitialValues();
      this.$emit('created', this);
    },
    destroyed: function destroyed () {
      this.$formulate.deregister(this);
    },
    methods: Object.assign({}, useRegistryMethods(),
      {applyErrors: function applyErrors (ref) {
        var formErrors = ref.formErrors;
        var inputErrors = ref.inputErrors;

        // given an object of errors, apply them to this form
        this.namedErrors = formErrors;
        this.namedFieldErrors = inputErrors;
      },
      addContextObserver: function addContextObserver (callback) {
        if (!this.contextObservers.find(function (observer) { return observer === callback; })) {
          this.contextObservers.push(callback);
          callback(this.formContext);
        }
      },
      removeContextObserver: function removeContextObserver (callback) {
        this.contextObservers.filter(function (observer) { return observer !== callback; });
      },
      registerErrorComponent: function registerErrorComponent (component) {
        if (!this.errorComponents.includes(component)) {
          this.errorComponents.push(component);
        }
      },
      formSubmitted: function formSubmitted () {
        var this$1$1 = this;

        if (this.isLoading) {
          return undefined
        }
        this.isLoading = true;

        // perform validation here
        this.showErrors();
        var submission = new FormSubmission(this);

        // Wait for the submission handler
        var submitRawHandler = this.$listeners['submit-raw'] || this.$listeners.submitRaw;
        var rawHandlerReturn = typeof submitRawHandler === 'function'
          ? submitRawHandler(submission)
          : Promise.resolve(submission);
        var willResolveRaw = rawHandlerReturn instanceof Promise
          ? rawHandlerReturn
          : Promise.resolve(rawHandlerReturn);
        return willResolveRaw
          .then(function (res) {
            var sub = (res instanceof FormSubmission ? res : submission);
            return sub.hasValidationErrors().then(function (hasErrors) { return [sub, hasErrors]; })
          })
          .then(function (ref) {
            var sub = ref[0];
            var hasErrors = ref[1];

            if (!hasErrors && typeof this$1$1.$listeners.submit === 'function') {
              return sub.values()
                .then(function (values) {
                  // If the listener returns a promise, we want to wait for that
                  // that promise to resolve, but when we do resolve, we only
                  // want to resolve the submission values
                  this$1$1.hasFailedSubmit = false;
                  var handlerReturn = this$1$1.$listeners.submit(values);
                  return (handlerReturn instanceof Promise ? handlerReturn : Promise.resolve())
                    .then(function () { return values; })
                })
            }
            return this$1$1.onFailedValidation()
          })
          .finally(function () {
            this$1$1.isLoading = false;
          })
      },
      onFailedValidation: function onFailedValidation () {
        this.hasFailedSubmit = true;
        this.$emit('failed-validation', Object.assign({}, this.failingFields));
        return this.$formulate.failedValidation(this)
      }})
  };

  /**
  * @vue/shared v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str, expectsLowerCase) {
    var set = new Set(str.split(","));
    return function (val) { return set.has(val); };
  }

  var EMPTY_OBJ = !!(process.env.NODE_ENV !== "production") ? Object.freeze({}) : {};
  var EMPTY_ARR = !!(process.env.NODE_ENV !== "production") ? Object.freeze([]) : [];
  var NOOP = function () {
  };
  var isOn = function (key) { return key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97); };
  var extend = Object.assign;
  var remove = function (arr, el) {
    var i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var hasOwn = function (val, key) { return hasOwnProperty$1.call(val, key); };
  var isArray = Array.isArray;
  var isMap = function (val) { return toTypeString(val) === "[object Map]"; };
  var isSet = function (val) { return toTypeString(val) === "[object Set]"; };
  var isDate = function (val) { return toTypeString(val) === "[object Date]"; };
  var isFunction = function (val) { return typeof val === "function"; };
  var isString = function (val) { return typeof val === "string"; };
  var isSymbol = function (val) { return typeof val === "symbol"; };
  var isObject = function (val) { return val !== null && typeof val === "object"; };
  var isPromise = function (val) {
    return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
  };
  var objectToString = Object.prototype.toString;
  var toTypeString = function (value) { return objectToString.call(value); };
  var toRawType = function (value) {
    return toTypeString(value).slice(8, -1);
  };
  var isPlainObject = function (val) { return toTypeString(val) === "[object Object]"; };
  var isIntegerKey = function (key) { return isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key; };
  var cacheStringFunction = function (fn) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var camelizeRE = /-(\w)/g;
  var camelize = cacheStringFunction(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ""; });
  });
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cacheStringFunction(
    function (str) { return str.replace(hyphenateRE, "-$1").toLowerCase(); }
  );
  var capitalize = cacheStringFunction(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  var toHandlerKey = cacheStringFunction(function (str) {
    var s = str ? ("on" + (capitalize(str))) : "";
    return s;
  });
  var hasChanged = function (value, oldValue) { return !Object.is(value, oldValue); };
  var invokeArrayFns = function (fns) {
    var arg = [], len = arguments.length - 1;
    while ( len-- > 0 ) arg[ len ] = arguments[ len + 1 ];

    for (var i = 0; i < fns.length; i++) {
      fns[i].apply(fns, arg);
    }
  };
  var def = function (obj, key, value, writable) {
    if ( writable === void 0 ) writable = false;

    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable: writable,
      value: value
    });
  };
  var looseToNumber = function (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  var _globalThis;
  var getGlobalThis = function () {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };

  function normalizeStyle(value) {
    if (isArray(value)) {
      var res = {};
      for (var i = 0; i < value.length; i++) {
        var item = value[i];
        var normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (var key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject(value)) {
      return value;
    }
  }
  var listDelimiterRE = /;(?![^(]*\))/g;
  var propertyDelimiterRE = /:([^]+)/;
  var styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    var ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    var res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        var normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value)) {
      for (var name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props) { return null; }
    var klass = props.class;
    var style = props.style;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }

  function looseCompareArrays(a, b) {
    if (a.length !== b.length) { return false; }
    var equal = true;
    for (var i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b) { return true; }
    var aValidType = isDate(a);
    var bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
      return a === b;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      var aKeysCount = Object.keys(a).length;
      var bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (var key in a) {
        var aHasKey = a.hasOwnProperty(key);
        var bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex(function (item) { return looseEqual(item, val); });
  }

  var isRef$1 = function (val) {
    return !!(val && val.__v_isRef === true);
  };
  var toDisplayString = function (val) {
    return isString(val) ? val : val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  var replacer = function (_key, val) {
    var obj, obj$1;

    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return ( obj = {}, obj[("Map(" + (val.size) + ")")] = [].concat( val.entries() ).reduce(
          function (entries, ref, i) {
            var key = ref[0];
            var val2 = ref[1];

            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        ), obj );
    } else if (isSet(val)) {
      return ( obj$1 = {}, obj$1[("Set(" + (val.size) + ")")] = [].concat( val.values() ).map(function (v) { return stringifySymbol(v); }), obj$1 );
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
      return String(val);
    }
    return val;
  };
  var stringifySymbol = function (v, i) {
    if ( i === void 0 ) i = "";

    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? ("Symbol(" + ((_a = v.description) != null ? _a : i) + ")") : v
    );
  };

  /**
  * @vue/reactivity v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  function warn$2(msg) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    console.warn.apply(console, [ ("[Vue warn] " + msg) ].concat( args ));
  }

  var activeEffectScope;
  var EffectScope = function EffectScope(detached) {
    if ( detached === void 0 ) detached = false;

    this.detached = detached;
    /**
     * @internal
     */
    this._active = true;
    /**
     * @internal
     */
    this.effects = [];
    /**
     * @internal
     */
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  };

  var prototypeAccessors = { active: { configurable: true } };
  prototypeAccessors.active.get = function () {
    return this._active;
  };
  EffectScope.prototype.run = function run (fn) {
    if (this._active) {
      var currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$2("cannot run an inactive effect scope.");
    }
  };
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  EffectScope.prototype.on = function on () {
    activeEffectScope = this;
  };
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  EffectScope.prototype.off = function off () {
    activeEffectScope = this.parent;
  };
  EffectScope.prototype.stop = function stop (fromParent) {
    if (this._active) {
      var i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        var last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  };

  Object.defineProperties( EffectScope.prototype, prototypeAccessors );
  function recordEffectScope(effect, scope) {
    if ( scope === void 0 ) scope = activeEffectScope;

    if (scope && scope.active) {
      scope.effects.push(effect);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }

  var activeEffect;
  var ReactiveEffect = function ReactiveEffect(fn, trigger, scheduler, scope) {
    this.fn = fn;
    this.trigger = trigger;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    /**
     * @internal
     */
    this._dirtyLevel = 4;
    /**
     * @internal
     */
    this._trackId = 0;
    /**
     * @internal
     */
    this._runnings = 0;
    /**
     * @internal
     */
    this._shouldSchedule = false;
    /**
     * @internal
     */
    this._depsLength = 0;
    recordEffectScope(this, scope);
  };

  var prototypeAccessors$1 = { dirty: { configurable: true } };
  prototypeAccessors$1.dirty.get = function () {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1;
      pauseTracking();
      for (var i = 0; i < this._depsLength; i++) {
        var dep = this.deps[i];
        if (dep.computed) {
          triggerComputed(dep.computed);
          if (this._dirtyLevel >= 4) {
            break;
          }
        }
      }
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
      }
      resetTracking();
    }
    return this._dirtyLevel >= 4;
  };
  prototypeAccessors$1.dirty.set = function (v) {
    this._dirtyLevel = v ? 4 : 0;
  };
  ReactiveEffect.prototype.run = function run () {
    this._dirtyLevel = 0;
    if (!this.active) {
      return this.fn();
    }
    var lastShouldTrack = shouldTrack;
    var lastEffect = activeEffect;
    try {
      shouldTrack = true;
      activeEffect = this;
      this._runnings++;
      preCleanupEffect(this);
      return this.fn();
    } finally {
      postCleanupEffect(this);
      this._runnings--;
      activeEffect = lastEffect;
      shouldTrack = lastShouldTrack;
    }
  };
  ReactiveEffect.prototype.stop = function stop () {
    if (this.active) {
      preCleanupEffect(this);
      postCleanupEffect(this);
      this.onStop && this.onStop();
      this.active = false;
    }
  };

  Object.defineProperties( ReactiveEffect.prototype, prototypeAccessors$1 );
  function triggerComputed(computed) {
    return computed.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps.length > effect2._depsLength) {
      for (var i = effect2._depsLength; i < effect2.deps.length; i++) {
        cleanupDepEffect(effect2.deps[i], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    var trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  var shouldTrack = true;
  var pauseScheduleStack = 0;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    var last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    var _a;
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      var oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
      if (!!(process.env.NODE_ENV !== "production")) {
        (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
      }
    }
  }
  var queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    var _a;
    pauseScheduling();
    for (var effect2 of dep.keys()) {
      var tracking = (void 0);
      if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
        effect2._dirtyLevel = dirtyLevel;
      }
      if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
        if (!!(process.env.NODE_ENV !== "production")) {
          (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        effect2.trigger();
        if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
          effect2._shouldSchedule = false;
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }

  var createDep = function (cleanup, computed) {
    var dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed;
    return dep;
  };

  var targetMap = /* @__PURE__ */ new WeakMap();
  var ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "iterate" : "");
  var MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== "production") ? "Map key iterate" : "");
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      var depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      var dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep(function () { return depsMap.delete(key); }));
      }
      trackEffect(
        activeEffect,
        dep,
        !!(process.env.NODE_ENV !== "production") ? {
          target: target,
          type: type,
          key: key
        } : void 0
      );
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    var depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    var deps = [];
    if (type === "clear") {
      deps = [].concat( depsMap.values() );
    } else if (key === "length" && isArray(target)) {
      var newLength = Number(newValue);
      depsMap.forEach(function (dep, key2) {
        if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (var dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          4,
          !!(process.env.NODE_ENV !== "production") ? {
            target: target,
            type: type,
            key: key,
            newValue: newValue,
            oldValue: oldValue,
            oldTarget: oldTarget
          } : void 0
        );
      }
    }
    resetScheduling();
  }

  var isNonTrackableKeys = /* @__PURE__ */ makeMap("__proto__,__v_isRef,__isVue");
  var builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter(function (key) { return key !== "arguments" && key !== "caller"; }).map(function (key) { return Symbol[key]; }).filter(isSymbol)
  );
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    var instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach(function (key) {
      instrumentations[key] = function() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        var arr = toRaw(this);
        for (var i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        var res = arr[key].apply(arr, args);
        if (res === -1 || res === false) {
          return arr[key].apply(arr, args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach(function (key) {
      instrumentations[key] = function() {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        pauseTracking();
        pauseScheduling();
        var res = toRaw(this)[key].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty(key) {
    if (!isSymbol(key)) { key = String(key); }
    var obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  var BaseReactiveHandler = function BaseReactiveHandler(_isReadonly, _isShallow) {
    if ( _isReadonly === void 0 ) _isReadonly = false;
    if ( _isShallow === void 0 ) _isShallow = false;

    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  };
  BaseReactiveHandler.prototype.get = function get (target, key, receiver) {
    var isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    var targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    var res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
  var MutableReactiveHandler = /*@__PURE__*/(function (BaseReactiveHandler) {
    function MutableReactiveHandler(isShallow2) {
      if ( isShallow2 === void 0 ) isShallow2 = false;

      BaseReactiveHandler.call(this, false, isShallow2);
    }

    if ( BaseReactiveHandler ) MutableReactiveHandler.__proto__ = BaseReactiveHandler;
    MutableReactiveHandler.prototype = Object.create( BaseReactiveHandler && BaseReactiveHandler.prototype );
    MutableReactiveHandler.prototype.constructor = MutableReactiveHandler;
    MutableReactiveHandler.prototype.set = function set (target, key, value, receiver) {
      var oldValue = target[key];
      if (!this._isShallow) {
        var isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      var hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      var result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
    MutableReactiveHandler.prototype.deleteProperty = function deleteProperty (target, key) {
      var hadKey = hasOwn(target, key);
      var oldValue = target[key];
      var result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger(target, "delete", key, void 0, oldValue);
      }
      return result;
    };
    MutableReactiveHandler.prototype.has = function has (target, key) {
      var result = Reflect.has(target, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    };
    MutableReactiveHandler.prototype.ownKeys = function ownKeys (target) {
      track(
        target,
        "iterate",
        isArray(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    };

    return MutableReactiveHandler;
  }(BaseReactiveHandler));
  var ReadonlyReactiveHandler = /*@__PURE__*/(function (BaseReactiveHandler) {
    function ReadonlyReactiveHandler(isShallow2) {
      if ( isShallow2 === void 0 ) isShallow2 = false;

      BaseReactiveHandler.call(this, true, isShallow2);
    }

    if ( BaseReactiveHandler ) ReadonlyReactiveHandler.__proto__ = BaseReactiveHandler;
    ReadonlyReactiveHandler.prototype = Object.create( BaseReactiveHandler && BaseReactiveHandler.prototype );
    ReadonlyReactiveHandler.prototype.constructor = ReadonlyReactiveHandler;
    ReadonlyReactiveHandler.prototype.set = function set (target, key) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$2(
          ("Set operation on key \"" + (String(key)) + "\" failed: target is readonly."),
          target
        );
      }
      return true;
    };
    ReadonlyReactiveHandler.prototype.deleteProperty = function deleteProperty (target, key) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$2(
          ("Delete operation on key \"" + (String(key)) + "\" failed: target is readonly."),
          target
        );
      }
      return true;
    };

    return ReadonlyReactiveHandler;
  }(BaseReactiveHandler));
  var mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  var readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  var shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);

  var toShallow = function (value) { return value; };
  var getProto = function (v) { return Reflect.getPrototypeOf(v); };
  function get(target, key, isReadonly2, isShallow2) {
    if ( isReadonly2 === void 0 ) isReadonly2 = false;
    if ( isShallow2 === void 0 ) isShallow2 = false;

    target = target["__v_raw"];
    var rawTarget = toRaw(target);
    var rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    var ref = getProto(rawTarget);
    var has2 = ref.has;
    var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly2) {
    if ( isReadonly2 === void 0 ) isReadonly2 = false;

    var target = this["__v_raw"];
    var rawTarget = toRaw(target);
    var rawKey = toRaw(key);
    if (!isReadonly2) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly2) {
    if ( isReadonly2 === void 0 ) isReadonly2 = false;

    target = target["__v_raw"];
    !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value, _isShallow) {
    if ( _isShallow === void 0 ) _isShallow = false;

    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    var target = toRaw(this);
    var proto = getProto(target);
    var hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set(key, value, _isShallow) {
    if ( _isShallow === void 0 ) _isShallow = false;

    if (!_isShallow && !isShallow(value) && !isReadonly(value)) {
      value = toRaw(value);
    }
    var target = toRaw(this);
    var ref = getProto(target);
    var has2 = ref.has;
    var get2 = ref.get;
    var hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (!!(process.env.NODE_ENV !== "production")) {
      checkIdentityKeys(target, has2, key);
    }
    var oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    var target = toRaw(this);
    var ref = getProto(target);
    var has2 = ref.has;
    var get2 = ref.get;
    var hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else if (!!(process.env.NODE_ENV !== "production")) {
      checkIdentityKeys(target, has2, key);
    }
    var oldValue = get2 ? get2.call(target, key) : void 0;
    var result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    var target = toRaw(this);
    var hadItems = target.size !== 0;
    var oldTarget = !!(process.env.NODE_ENV !== "production") ? isMap(target) ? new Map(target) : new Set(target) : void 0;
    var result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow2) {
    return function forEach(callback, thisArg) {
      var observed = this;
      var target = observed["__v_raw"];
      var rawTarget = toRaw(target);
      var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach(function (value, key) {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function() {
      var obj;

      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];
      var target = this["__v_raw"];
      var rawTarget = toRaw(target);
      var targetIsMap = isMap(rawTarget);
      var isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      var isKeyOnly = method === "keys" && targetIsMap;
      var innerIterator = target[method].apply(target, args);
      var wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return ( obj = {
        // iterator protocol
        next: function next() {
          var ref = innerIterator.next();
          var value = ref.value;
          var done = ref.done;
          return done ? { value: value, done: done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done: done
          };
        }
      }, obj[Symbol.iterator] = function () {
          return this;
        }, obj );
    };
  }
  function createReadonlyMethod(type) {
    return function() {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (!!(process.env.NODE_ENV !== "production")) {
        var key = args[0] ? ("on key \"" + (args[0]) + "\" ") : "";
        warn$2(
          ((capitalize(type)) + " operation " + key + "failed: target is readonly."),
          toRaw(this)
        );
      }
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    var mutableInstrumentations2 = {
      get: function get$1(key) {
        return get(this, key);
      },
      get size() {
        return size(this);
      },
      has: has,
      add: add,
      set: set,
      delete: deleteEntry,
      clear: clear,
      forEach: createForEach(false, false)
    };
    var shallowInstrumentations2 = {
      get: function get$2(key) {
        return get(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has,
      add: function add$1(value) {
        return add.call(this, value, true);
      },
      set: function set$1(key, value) {
        return set.call(this, key, value, true);
      },
      delete: deleteEntry,
      clear: clear,
      forEach: createForEach(false, true)
    };
    var readonlyInstrumentations2 = {
      get: function get$3(key) {
        return get(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has: function has$1(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    var shallowReadonlyInstrumentations2 = {
      get: function get$4(key) {
        return get(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has: function has$2(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    var iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach(function (method) {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var ref$1 = /* @__PURE__ */ createInstrumentations();
  var mutableInstrumentations = ref$1[0];
  var readonlyInstrumentations = ref$1[1];
  var shallowInstrumentations = ref$1[2];
  var shallowReadonlyInstrumentations = ref$1[3];
  function createInstrumentationGetter(isReadonly2, shallow) {
    var instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return function (target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  var shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  function checkIdentityKeys(target, has2, key) {
    var rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      var type = toRawType(target);
      warn$2(
        ("Reactive " + type + " contains both the raw and reactive versions of the same object" + (type === "Map" ? " as keys" : "") + ", which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.")
      );
    }
  }

  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1 /* COMMON */;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2 /* COLLECTION */;
      default:
        return 0 /* INVALID */;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target) {
    return createReactiveObject(
      target,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      if (!!(process.env.NODE_ENV !== "production")) {
        warn$2(
          ("value cannot be made " + (isReadonly2 ? "readonly" : "reactive") + ": " + (String(
            target
          )))
        );
      }
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    var existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    var targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
      return target;
    }
    var proxy = new Proxy(
      target,
      targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    var raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    if (Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  var toReactive = function (value) { return isObject(value) ? reactive(value) : value; };
  var toReadonly = function (value) { return isObject(value) ? readonly(value) : value; };
  function isRef(r) {
    return !!(r && r.__v_isRef === true);
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  var shallowUnwrapHandlers = {
    get: function (target, key, receiver) { return unref(Reflect.get(target, key, receiver)); },
    set: function (target, key, value, receiver) {
      var oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }

  /**
  * @vue/runtime-core v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  var stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  var isWarning = false;
  function warn$1(msg) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    if (isWarning) { return; }
    isWarning = true;
    pauseTracking();
    var instance = stack.length ? stack[stack.length - 1].component : null;
    var appWarnHandler = instance && instance.appContext.config.warnHandler;
    var trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map(function (a) {
            var _a, _b;
            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            function (ref) {
              var vnode = ref.vnode;

              return ("at <" + (formatComponentName(instance, vnode.type)) + ">");
      }
          ).join("\n"),
          trace
        ]
      );
    } else {
      var warnArgs = [("[Vue warn]: " + msg) ].concat( args);
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push.apply(warnArgs, [ "\n" ].concat( formatTrace(trace) ));
      }
      console.warn.apply(console, warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    var currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    var normalizedStack = [];
    while (currentVNode) {
      var last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      var parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    var logs = [];
    trace.forEach(function (entry, i) {
      logs.push.apply(logs, ( i === 0 ? [] : ["\n"] ).concat( formatTraceEntry(entry) ));
    });
    return logs;
  }
  function formatTraceEntry(ref) {
    var vnode = ref.vnode;
    var recurseCount = ref.recurseCount;

    var postfix = recurseCount > 0 ? ("... (" + recurseCount + " recursive calls)") : "";
    var isRoot = vnode.component ? vnode.component.parent == null : false;
    var open = " at <" + (formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    ));
    var close = ">" + postfix;
    return vnode.props ? [open ].concat( formatProps(vnode.props), [close]) : [open + close];
  }
  function formatProps(props) {
    var res = [];
    var keys = Object.keys(props);
    keys.slice(0, 3).forEach(function (key) {
      res.push.apply(res, formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(" ...");
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [(key + "=" + value)];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [(key + "=" + value)];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [(key + "=Ref<"), value, ">"];
    } else if (isFunction(value)) {
      return [(key + "=fn" + (value.name ? ("<" + (value.name) + ">") : ""))];
    } else {
      value = toRaw(value);
      return raw ? value : [(key + "="), value];
    }
  }
  var ErrorTypeStrings$1 = {};
  ErrorTypeStrings$1["sp"] = "serverPrefetch hook";
  ErrorTypeStrings$1["bc"] = "beforeCreate hook";
  ErrorTypeStrings$1["c"] = "created hook";
  ErrorTypeStrings$1["bm"] = "beforeMount hook";
  ErrorTypeStrings$1["m"] = "mounted hook";
  ErrorTypeStrings$1["bu"] = "beforeUpdate hook";
  ErrorTypeStrings$1["u"] = "updated";
  ErrorTypeStrings$1["bum"] = "beforeUnmount hook";
  ErrorTypeStrings$1["um"] = "unmounted hook";
  ErrorTypeStrings$1["a"] = "activated hook";
  ErrorTypeStrings$1["da"] = "deactivated hook";
  ErrorTypeStrings$1["ec"] = "errorCaptured hook";
  ErrorTypeStrings$1["rtc"] = "renderTracked hook";
  ErrorTypeStrings$1["rtg"] = "renderTriggered hook";
  ErrorTypeStrings$1[0] = "setup function";
  ErrorTypeStrings$1[1] = "render function";
  ErrorTypeStrings$1[2] = "watcher getter";
  ErrorTypeStrings$1[3] = "watcher callback";
  ErrorTypeStrings$1[4] = "watcher cleanup function";
  ErrorTypeStrings$1[5] = "native event handler";
  ErrorTypeStrings$1[6] = "component event handler";
  ErrorTypeStrings$1[7] = "vnode hook";
  ErrorTypeStrings$1[8] = "directive hook";
  ErrorTypeStrings$1[9] = "transition hook";
  ErrorTypeStrings$1[10] = "app errorHandler";
  ErrorTypeStrings$1[11] = "app warnHandler";
  ErrorTypeStrings$1[12] = "ref function";
  ErrorTypeStrings$1[13] = "async component loader";
  ErrorTypeStrings$1[14] = "scheduler flush";
  ErrorTypeStrings$1[15] = "component update";
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn.apply(void 0, args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction(fn)) {
      var res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch(function (err) {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray(fn)) {
      var values = [];
      for (var i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1(
        ("Invalid value type passed to callWithAsyncErrorHandling(): " + (typeof fn))
      );
    }
  }
  function handleError(err, instance, type, throwInDev) {
    if ( throwInDev === void 0 ) throwInDev = true;

    var contextVNode = instance ? instance.vnode : null;
    if (instance) {
      var cur = instance.parent;
      var exposedInstance = instance.proxy;
      var errorInfo = !!(process.env.NODE_ENV !== "production") ? ErrorTypeStrings$1[type] : ("https://vuejs.org/error-reference/#runtime-" + type);
      while (cur) {
        var errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (var i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      var appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        pauseTracking();
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev) {
    if ( throwInDev === void 0 ) throwInDev = true;

    if (!!(process.env.NODE_ENV !== "production")) {
      var info = ErrorTypeStrings$1[type];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn$1(("Unhandled error" + (info ? (" during execution of " + info) : "")));
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }

  var isFlushing = false;
  var isFlushPending = false;
  var queue = [];
  var flushIndex = 0;
  var pendingPostFlushCbs = [];
  var activePostFlushCbs = null;
  var postFlushIndex = 0;
  var resolvedPromise = /* @__PURE__ */ Promise.resolve();
  var currentFlushPromise = null;
  var RECURSION_LIMIT = 100;
  function nextTick(fn) {
    var p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
  }
  function findInsertionIndex(id) {
    var start = flushIndex + 1;
    var end = queue.length;
    while (start < end) {
      var middle = start + end >>> 1;
      var middleJob = queue[middle];
      var middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push.apply(pendingPostFlushCbs, cb);
    }
    queueFlush();
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      var deduped = [].concat( new Set(pendingPostFlushCbs) ).sort(
        function (a, b) { return getId(a) - getId(b); }
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push.apply(activePostFlushCbs, deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (!!(process.env.NODE_ENV !== "production")) {
        seen = seen || /* @__PURE__ */ new Map();
      }
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        var cb = activePostFlushCbs[postFlushIndex];
        if (!!(process.env.NODE_ENV !== "production") && checkRecursiveUpdates(seen, cb)) {
          continue;
        }
        if (cb.active !== false) { cb(); }
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  var getId = function (job) { return job.id == null ? Infinity : job.id; };
  var comparator = function (a, b) {
    var diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre) { return -1; }
      if (b.pre && !a.pre) { return 1; }
    }
    return diff;
  };
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    if (!!(process.env.NODE_ENV !== "production")) {
      seen = seen || /* @__PURE__ */ new Map();
    }
    queue.sort(comparator);
    var check = !!(process.env.NODE_ENV !== "production") ? function (job) { return checkRecursiveUpdates(seen, job); } : NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        var job = queue[flushIndex];
        if (job && job.active !== false) {
          if (!!(process.env.NODE_ENV !== "production") && check(job)) {
            continue;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs(seen);
      }
    }
  }
  function checkRecursiveUpdates(seen, fn) {
    if (!seen.has(fn)) {
      seen.set(fn, 1);
    } else {
      var count = seen.get(fn);
      if (count > RECURSION_LIMIT) {
        var instance = fn.i;
        var componentName = instance && getComponentName(instance.type);
        handleError(
          ("Maximum recursive updates exceeded" + (componentName ? (" in component <" + componentName + ">") : "") + ". This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function."),
          null,
          10
        );
        return true;
      } else {
        seen.set(fn, count + 1);
      }
    }
  }
  var hmrDirtyComponents = /* @__PURE__ */ new Map();
  if (!!(process.env.NODE_ENV !== "production")) {
    getGlobalThis().__VUE_HMR_RUNTIME__ = {
      createRecord: tryWrap(createRecord),
      rerender: tryWrap(rerender),
      reload: tryWrap(reload)
    };
  }
  var map = /* @__PURE__ */ new Map();
  function createRecord(id, initialDef) {
    if (map.has(id)) {
      return false;
    }
    map.set(id, {
      initialDef: normalizeClassComponent(initialDef),
      instances: /* @__PURE__ */ new Set()
    });
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id, newRender) {
    var record = map.get(id);
    if (!record) {
      return;
    }
    record.initialDef.render = newRender;
    [].concat( record.instances ).forEach(function (instance) {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      instance.effect.dirty = true;
      instance.update();
    });
  }
  function reload(id, newComp) {
    var record = map.get(id);
    if (!record) { return; }
    newComp = normalizeClassComponent(newComp);
    updateComponentDef(record.initialDef, newComp);
    var instances = [].concat( record.instances );
    var loop = function ( i ) {
      var instance = instances[i];
      var oldComp = normalizeClassComponent(instance.type);
      var dirtyInstances = hmrDirtyComponents.get(oldComp);
      if (!dirtyInstances) {
        if (oldComp !== record.initialDef) {
          updateComponentDef(oldComp, newComp);
        }
        hmrDirtyComponents.set(oldComp, dirtyInstances = /* @__PURE__ */ new Set());
      }
      dirtyInstances.add(instance);
      instance.appContext.propsCache.delete(instance.type);
      instance.appContext.emitsCache.delete(instance.type);
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        dirtyInstances.add(instance);
        instance.ceReload(newComp.styles);
        dirtyInstances.delete(instance);
      } else if (instance.parent) {
        instance.parent.effect.dirty = true;
        queueJob(function () {
          instance.parent.update();
          dirtyInstances.delete(instance);
        });
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn(
          "[HMR] Root or manually mounted instance modified. Full reload required."
        );
      }
    };

    for (var i = 0; i < instances.length; i++) loop( i );
    queuePostFlushCb(function () {
      hmrDirtyComponents.clear();
    });
  }
  function updateComponentDef(oldComp, newComp) {
    extend(oldComp, newComp);
    for (var key in oldComp) {
      if (key !== "__file" && !(key in newComp)) {
        delete oldComp[key];
      }
    }
  }
  function tryWrap(fn) {
    return function (id, arg) {
      try {
        return fn(id, arg);
      } catch (e) {
        console.error(e);
        console.warn(
          "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
        );
      }
    };
  }

  var devtools$1;
  var buffer = [];
  var devtoolsNotInstalled = false;
  function emit$1(event) {
    var args = [], len = arguments.length - 1;
    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

    if (devtools$1) {
      devtools$1.emit.apply(devtools$1, [ event ].concat( args ));
    } else if (!devtoolsNotInstalled) {
      buffer.push({ event: event, args: args });
    }
  }
  function setDevtoolsHook$1(hook, target) {
    var _a, _b;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(function (ref) {
        var event = ref.event;
        var args = ref.args;

        return devtools$1.emit.apply(devtools$1, [ event ].concat( args ));
      });
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
    ) {
      var replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push(function (newHook) {
        setDevtoolsHook$1(newHook, target);
      });
      setTimeout(function () {
        if (!devtools$1) {
          target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          devtoolsNotInstalled = true;
          buffer = [];
        }
      }, 3e3);
    } else {
      devtoolsNotInstalled = true;
      buffer = [];
    }
  }
  var devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated" /* COMPONENT_UPDATED */);
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function createDevtoolsComponentHook(hook) {
    return function (component) {
      emit$1(
        hook,
        component.appContext.app,
        component.uid,
        component.parent ? component.parent.uid : void 0,
        component
      );
    };
  }

  var currentRenderingInstance = null;
  var currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    var prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx, isNonScopedSlot) {
    if ( ctx === void 0 ) ctx = currentRenderingInstance;

    if (!ctx) { return fn; }
    if (fn._n) {
      return fn;
    }
    var renderFnWithContext = function () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      var prevInstance = setCurrentRenderingInstance(ctx);
      var res;
      try {
        res = fn.apply(void 0, args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      if (!!(process.env.NODE_ENV !== "production") || __VUE_PROD_DEVTOOLS__) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      !!(process.env.NODE_ENV !== "production") && warn$1("withDirectives can only be used inside render functions.");
      return vnode;
    }
    var instance = getComponentPublicInstance(currentRenderingInstance);
    var bindings = vnode.dirs || (vnode.dirs = []);
    for (var i = 0; i < directives.length; i++) {
      var ref = directives[i];
      var dir = ref[0];
      var value = ref[1];
      var arg = ref[2];
      var modifiers = ref[3]; if ( modifiers === void 0 ) modifiers = EMPTY_OBJ;
      if (dir) {
        if (isFunction(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir: dir,
          instance: instance,
          value: value,
          oldValue: void 0,
          arg: arg,
          modifiers: modifiers
        });
      }
    }
    return vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }

  var isAsyncWrapper = function (i) { return !!i.type.__asyncLoader; };

  var COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  var NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveAsset(type, name, warnMissing, maybeSelfReference) {
    if ( warnMissing === void 0 ) warnMissing = true;
    if ( maybeSelfReference === void 0 ) maybeSelfReference = false;

    var instance = currentRenderingInstance || currentInstance;
    if (instance) {
      var Component = instance.type;
      {
        var selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      var res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      if (!!(process.env.NODE_ENV !== "production") && warnMissing && !res) {
        var extra = "\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement." ;
        warn$1(("Failed to resolve " + (type.slice(0, -1)) + ": " + name + extra));
      }
      return res;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1(
        ("resolve" + (capitalize(type.slice(0, -1))) + " can only be used in render() or setup().")
      );
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }

  function renderList(source, renderItem, cache, index) {
    var ret;
    var cached = cache;
    if (isArray(source) || isString(source)) {
      ret = new Array(source.length);
      for (var i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(source[i], i, void 0, cached);
      }
    } else if (typeof source === "number") {
      if (!!(process.env.NODE_ENV !== "production") && !Number.isInteger(source)) {
        warn$1(("The v-for range expect an integer value but got " + source + "."));
      }
      ret = new Array(source);
      for (var i$1 = 0; i$1 < source; i$1++) {
        ret[i$1] = renderItem(i$1 + 1, i$1, void 0, cached);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          function (item, i) { return renderItem(item, i, void 0, cached); }
        );
      } else {
        var keys = Object.keys(source);
        ret = new Array(keys.length);
        for (var i$2 = 0, l$1 = keys.length; i$2 < l$1; i$2++) {
          var key = keys[i$2];
          ret[i$2] = renderItem(source[key], key, i$2, cached);
        }
      }
    } else {
      ret = [];
    }
    return ret;
  }

  function renderSlot(slots, name, props, fallback, noSlotted) {
    if ( props === void 0 ) props = {};

    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default") { props.name = name; }
      return createVNode("slot", props, fallback && fallback());
    }
    var slot = slots[name];
    if (!!(process.env.NODE_ENV !== "production") && slot && slot.length > 1) {
      warn$1(
        "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
      );
      slot = function () { return []; };
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    var validSlotContent = slot && ensureValidVNode(slot(props));
    var rendered = createBlock(
      Fragment,
      {
        key: (props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || ("_" + name)) + // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some(function (child) {
      if (!isVNode(child)) { return true; }
      if (child.type === Comment) { return false; }
      if (child.type === Fragment && !ensureValidVNode(child.children))
        { return false; }
      return true;
    }) ? vnodes : null;
  }

  function toHandlers(obj, preserveCaseIfNecessary) {
    var ret = {};
    if (!!(process.env.NODE_ENV !== "production") && !isObject(obj)) {
      warn$1("v-on with no argument expects an object value.");
      return ret;
    }
    for (var key in obj) {
      ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? ("on:" + key) : toHandlerKey(key)] = obj[key];
    }
    return ret;
  }

  var getPublicInstance = function (i) {
    if (!i) { return null; }
    if (isStatefulComponent(i)) { return getComponentPublicInstance(i); }
    return getPublicInstance(i.parent);
  };
  var publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: function (i) { return i; },
      $el: function (i) { return i.vnode.el; },
      $data: function (i) { return i.data; },
      $props: function (i) { return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.props) : i.props; },
      $attrs: function (i) { return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.attrs) : i.attrs; },
      $slots: function (i) { return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.slots) : i.slots; },
      $refs: function (i) { return !!(process.env.NODE_ENV !== "production") ? shallowReadonly(i.refs) : i.refs; },
      $parent: function (i) { return getPublicInstance(i.parent); },
      $root: function (i) { return getPublicInstance(i.root); },
      $emit: function (i) { return i.emit; },
      $options: function (i) { return __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type; },
      $forceUpdate: function (i) { return i.f || (i.f = function () {
        i.effect.dirty = true;
        queueJob(i.update);
      }); },
      $nextTick: function (i) { return i.n || (i.n = nextTick.bind(i.proxy)); },
      $watch: function (i) { return __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP; }
    })
  );
  var isReservedPrefix = function (key) { return key === "_" || key === "$"; };
  var hasSetupBinding = function (state, key) { return state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key); };
  var PublicInstanceProxyHandlers = {
    get: function get(ref, key) {
      var instance = ref._;

      if (key === "__v_skip") {
        return true;
      }
      var ctx = instance.ctx;
      var setupState = instance.setupState;
      var data = instance.data;
      var props = instance.props;
      var accessCache = instance.accessCache;
      var type = instance.type;
      var appContext = instance.appContext;
      if (!!(process.env.NODE_ENV !== "production") && key === "__isVue") {
        return true;
      }
      var normalizedProps;
      if (key[0] !== "$") {
        var n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1 /* SETUP */:
              return setupState[key];
            case 2 /* DATA */:
              return data[key];
            case 4 /* CONTEXT */:
              return ctx[key];
            case 3 /* PROPS */:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1 /* SETUP */;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2 /* DATA */;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3 /* PROPS */;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4 /* CONTEXT */;
          return ctx[key];
        } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
          accessCache[key] = 0 /* OTHER */;
        }
      }
      var publicGetter = publicPropertiesMap[key];
      var cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
          !!(process.env.NODE_ENV !== "production") && markAttrsAccessed();
        } else if (!!(process.env.NODE_ENV !== "production") && key === "$slots") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else if (!!(process.env.NODE_ENV !== "production") && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      key.indexOf("__v") !== 0)) {
        if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
          warn$1(
            ("Property " + (JSON.stringify(
              key
            )) + " must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.")
          );
        } else if (instance === currentRenderingInstance) {
          warn$1(
            ("Property " + (JSON.stringify(key)) + " was accessed during render but is not defined on instance.")
          );
        }
      }
    },
    set: function set(ref, key, value) {
      var instance = ref._;

      var data = instance.data;
      var setupState = instance.setupState;
      var ctx = instance.ctx;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (!!(process.env.NODE_ENV !== "production") && setupState.__isScriptSetup && hasOwn(setupState, key)) {
        warn$1(("Cannot mutate <script setup> binding \"" + key + "\" from Options API."));
        return false;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        !!(process.env.NODE_ENV !== "production") && warn$1(("Attempting to mutate prop \"" + key + "\". Props are readonly."));
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        !!(process.env.NODE_ENV !== "production") && warn$1(
          ("Attempting to mutate public property \"" + key + "\". Properties starting with $ are reserved and readonly.")
        );
        return false;
      } else {
        if (!!(process.env.NODE_ENV !== "production") && key in instance.appContext.config.globalProperties) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            value: value
          });
        } else {
          ctx[key] = value;
        }
      }
      return true;
    },
    has: function has(ref, key) {
      var ref_ = ref._;
      var data = ref_.data;
      var setupState = ref_.setupState;
      var accessCache = ref_.accessCache;
      var ctx = ref_.ctx;
      var appContext = ref_.appContext;
      var propsOptions = ref_.propsOptions;

      var normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty: function defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  if (!!(process.env.NODE_ENV !== "production") && true) {
    PublicInstanceProxyHandlers.ownKeys = function (target) {
      warn$1(
        "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
      );
      return Reflect.ownKeys(target);
    };
  }
  function normalizePropsOrEmits(props) {
    return isArray(props) ? props.reduce(
      function (normalized, p) { return (normalized[p] = null, normalized); },
      {}
    ) : props;
  }
  var shouldCacheAccess = true;
  function resolveMergedOptions(instance) {
    var base = instance.type;
    var mixins = base.mixins;
    var extendsOptions = base.extends;
    var ref = instance.appContext;
    var globalMixins = ref.mixins;
    var cache = ref.optionsCache;
    var optionMergeStrategies = ref.config.optionMergeStrategies;
    var cached = cache.get(base);
    var resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          function (m) { return mergeOptions(resolved, m, optionMergeStrategies, true); }
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin) {
    if ( asMixin === void 0 ) asMixin = false;

    var mixins = from.mixins;
    var extendsOptions = from.extends;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        function (m) { return mergeOptions(to, m, strats, true); }
      );
    }
    for (var key in from) {
      if (asMixin && key === "expose") {
        !!(process.env.NODE_ENV !== "production") && warn$1(
          "\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself."
        );
      } else {
        var strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  var internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return (extend)(
        isFunction(to) ? to.call(this, this) : to,
        isFunction(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      var res = {};
      for (var i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [].concat( new Set([].concat(to, from)) ) : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray(to) && isArray(from)) {
        return [].concat( new Set(to.concat( from)) );
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to) { return from; }
    if (!from) { return to; }
    var merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (var key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }
  var currentApp = null;
  function inject(key, defaultValue, treatDefaultAsFactory) {
    if ( treatDefaultAsFactory === void 0 ) treatDefaultAsFactory = false;

    var instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      var provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else if (!!(process.env.NODE_ENV !== "production")) {
        warn$1(("injection \"" + (String(key)) + "\" not found."));
      }
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn$1("inject() can only be used inside setup() or functional components.");
    }
  }

  var internalObjectProto = {};
  var isInternalObject = function (obj) { return Object.getPrototypeOf(obj) === internalObjectProto; };
  var isTeleport = function (type) { return type.__isTeleport; };

  var queuePostRenderEffect = queueEffectWithSuspense ;

  var ssrContextKey = Symbol.for("v-scx");
  var useSSRContext = function () {
    {
      var ctx = inject(ssrContextKey);
      if (!ctx) {
        !!(process.env.NODE_ENV !== "production") && warn$1(
          "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
        );
      }
      return ctx;
    }
  };
  var INITIAL_WATCHER_VALUE = {};
  function doWatch(source, cb, ref) {
    if ( ref === void 0 ) ref = EMPTY_OBJ;
    var immediate = ref.immediate;
    var deep = ref.deep;
    var flush = ref.flush;
    var once = ref.once;
    var onTrack = ref.onTrack;
    var onTrigger = ref.onTrigger;

    if (cb && once) {
      var _cb = cb;
      cb = function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        _cb.apply(void 0, args);
        unwatch();
      };
    }
    if (!!(process.env.NODE_ENV !== "production") && deep !== void 0 && typeof deep === "number") {
      warn$1(
        "watch() \"deep\" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage."
      );
    }
    if (!!(process.env.NODE_ENV !== "production") && !cb) {
      if (immediate !== void 0) {
        warn$1(
          "watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature."
        );
      }
      if (deep !== void 0) {
        warn$1(
          "watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature."
        );
      }
      if (once !== void 0) {
        warn$1(
          "watch() \"once\" option is only respected when using the watch(source, callback, options?) signature."
        );
      }
    }
    var warnInvalidSource = function (s) {
      warn$1(
        "Invalid watch source: ",
        s,
        "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
      );
    };
    var instance = currentInstance;
    var reactiveGetter = function (source2) { return deep === true ? source2 : (
      // for deep: false, only traverse root-level properties
      traverse(source2, deep === false ? 1 : void 0)
    ); };
    var getter;
    var forceTrigger = false;
    var isMultiSource = false;
    if (isRef(source)) {
      getter = function () { return source.value; };
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = function () { return reactiveGetter(source); };
      forceTrigger = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });
      getter = function () { return source.map(function (s) {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return reactiveGetter(s);
        } else if (isFunction(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else {
          !!(process.env.NODE_ENV !== "production") && warnInvalidSource(s);
        }
      }); };
    } else if (isFunction(source)) {
      if (cb) {
        getter = function () { return callWithErrorHandling(source, instance, 2); };
      } else {
        getter = function () {
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
      !!(process.env.NODE_ENV !== "production") && warnInvalidSource(source);
    }
    if (cb && deep) {
      var baseGetter = getter;
      getter = function () { return traverse(baseGetter()); };
    }
    var cleanup;
    var onCleanup = function (fn) {
      cleanup = effect.onStop = function () {
        callWithErrorHandling(fn, instance, 4);
        cleanup = effect.onStop = void 0;
      };
    };
    var ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        var ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    var oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    var job = function () {
      if (!effect.active || !effect.dirty) {
        return;
      }
      if (cb) {
        var newValue = effect.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some(function (v, i) { return hasChanged(v, oldValue[i]); }) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect.run();
      }
    };
    job.allowRecurse = !!cb;
    var scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = function () { return queuePostRenderEffect(job, instance && instance.suspense); };
    } else {
      job.pre = true;
      if (instance) { job.id = instance.uid; }
      scheduler = function () { return queueJob(job); };
    }
    var effect = new ReactiveEffect(getter, NOOP, scheduler);
    var scope = getCurrentScope();
    var unwatch = function () {
      effect.stop();
      if (scope) {
        remove(scope.effects, effect);
      }
    };
    if (!!(process.env.NODE_ENV !== "production")) {
      effect.onTrack = onTrack;
      effect.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect.run.bind(effect),
        instance && instance.suspense
      );
    } else {
      effect.run();
    }
    if (ssrCleanup) { ssrCleanup.push(unwatch); }
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    var publicThis = this.proxy;
    var getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : function () { return publicThis[source]; } : source.bind(publicThis, publicThis);
    var cb;
    if (isFunction(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    var reset = setCurrentInstance(this);
    var res = doWatch(getter, cb.bind(publicThis), options);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    var segments = path.split(".");
    return function () {
      var cur = ctx;
      for (var i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value, depth, seen) {
    if ( depth === void 0 ) depth = Infinity;

    if (depth <= 0 || !isObject(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray(value)) {
      for (var i = 0; i < value.length; i++) {
        traverse(value[i], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach(function (v) {
        traverse(v, depth, seen);
      });
    } else if (isPlainObject(value)) {
      for (var key in value) {
        traverse(value[key], depth, seen);
      }
      for (var key$1 of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key$1)) {
          traverse(value[key$1], depth, seen);
        }
      }
    }
    return value;
  }
  function markAttrsAccessed() {
  }

  var isSuspense = function (type) { return type.__isSuspense; };
  function queueEffectWithSuspense(fn, suspense) {
    var ref;

    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        (ref = suspense.effects).push.apply(ref, fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }

  var Fragment = Symbol.for("v-fgt");
  var Text = Symbol.for("v-txt");
  var Comment = Symbol.for("v-cmt");
  var blockStack = [];
  var currentBlock = null;
  function openBlock(disableTracking) {
    if ( disableTracking === void 0 ) disableTracking = false;

    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  var isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  var createVNodeWithArgsTransform = function () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return _createVNode.apply(
      void 0, args
    );
  };
  var normalizeKey = function (ref) {
    var key = ref.key;

    return key != null ? key : null;
  };
  var normalizeRef = function (ref$1) {
    var ref = ref$1.ref;
    var ref_key = ref$1.ref_key;
    var ref_for = ref$1.ref_for;

    if (typeof ref === "number") {
      ref = "" + ref;
    }
    return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
  };
  function createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, needFullChildrenNormalization) {
    if ( props === void 0 ) props = null;
    if ( children === void 0 ) children = null;
    if ( patchFlag === void 0 ) patchFlag = 0;
    if ( dynamicProps === void 0 ) dynamicProps = null;
    if ( shapeFlag === void 0 ) shapeFlag = type === Fragment ? 0 : 1;
    if ( isBlockNode === void 0 ) isBlockNode = false;
    if ( needFullChildrenNormalization === void 0 ) needFullChildrenNormalization = false;

    var vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type,
      props: props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children: children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: shapeFlag,
      patchFlag: patchFlag,
      dynamicProps: dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (!!(process.env.NODE_ENV !== "production") && vnode.key !== vnode.key) {
      warn$1("VNode created with invalid key (NaN). VNode type:", vnode.type);
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  var createVNode = !!(process.env.NODE_ENV !== "production") ? createVNodeWithArgsTransform : _createVNode;
  function _createVNode(type, props, children, patchFlag, dynamicProps, isBlockNode) {
    if ( props === void 0 ) props = null;
    if ( children === void 0 ) children = null;
    if ( patchFlag === void 0 ) patchFlag = 0;
    if ( dynamicProps === void 0 ) dynamicProps = null;
    if ( isBlockNode === void 0 ) isBlockNode = false;

    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      if (!!(process.env.NODE_ENV !== "production") && !type) {
        warn$1(("Invalid vnode type when creating vnode: " + type + "."));
      }
      type = Comment;
    }
    if (isVNode(type)) {
      var cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      var klass = props.class;
      var style = props.style;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject(style)) {
        if (isProxy(style) && !isArray(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    var shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
    if (!!(process.env.NODE_ENV !== "production") && shapeFlag & 4 && isProxy(type)) {
      type = toRaw(type);
      warn$1(
        "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
        "\nComponent that was made reactive: ",
        type
      );
    }
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) { return null; }
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef, cloneTransition) {
    if ( mergeRef === void 0 ) mergeRef = false;
    if ( cloneTransition === void 0 ) cloneTransition = false;

    var props = vnode.props;
    var ref = vnode.ref;
    var patchFlag = vnode.patchFlag;
    var children = vnode.children;
    var transition = vnode.transition;
    var mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    var cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: !!(process.env.NODE_ENV !== "production") && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function deepCloneVNode(vnode) {
    var cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text, flag) {
    if ( text === void 0 ) text = " ";
    if ( flag === void 0 ) flag = 0;

    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text, asBlock) {
    if ( text === void 0 ) text = "";
    if ( asBlock === void 0 ) asBlock = false;

    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeChildren(vnode, children) {
    var type = 0;
    var shapeFlag = vnode.shapeFlag;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        var slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        var slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps() {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var ret = {};
    for (var i = 0; i < args.length; i++) {
      var toMerge = args[i];
      for (var key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          var existing = ret[key];
          var incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  var currentInstance = null;
  var internalSetCurrentInstance;
  {
    var g = getGlobalThis();
    var registerGlobalSetter = function (key, setter) {
      var setters;
      if (!(setters = g[key])) { setters = g[key] = []; }
      setters.push(setter);
      return function (v) {
        if (setters.length > 1) { setters.forEach(function (set) { return set(v); }); }
        else { setters[0](v); }
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      "__VUE_INSTANCE_SETTERS__",
      function (v) { return currentInstance = v; }
    );
    registerGlobalSetter(
      "__VUE_SSR_SETTERS__",
      function (v) { return isInSSRComponentSetup = v; }
    );
  }
  var setCurrentInstance = function (instance) {
    var prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return function () {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  var isInSSRComponentSetup = false;
  !!(process.env.NODE_ENV !== "production") ? {
    get: function get(target, key) {
      track(target, "get", "");
      return target[key];
    },
    set: function set() {
      warn$1("setupContext.attrs is readonly.");
      return false;
    },
    deleteProperty: function deleteProperty() {
      warn$1("setupContext.attrs is readonly.");
      return false;
    }
  } : {
    get: function get(target, key) {
      track(target, "get", "");
      return target[key];
    }
  };
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get: function get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has: function has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str.replace(classifyRE, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, ""); };
  function getComponentName(Component, includeInferred) {
    if ( includeInferred === void 0 ) includeInferred = true;

    return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot) {
    if ( isRoot === void 0 ) isRoot = false;

    var name = getComponentName(Component);
    if (!name && Component.__file) {
      var match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      var inferFromRegistry = function (registry) {
        for (var key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? "App" : "Anonymous";
  }
  function isClassComponent(value) {
    return isFunction(value) && "__vccOpts" in value;
  }

  function initCustomFormatter() {
    if (!!!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
      return;
    }
    var vueStyle = { style: "color:#3ba776" };
    var numberStyle = { style: "color:#1677ff" };
    var stringStyle = { style: "color:#f5222d" };
    var keywordStyle = { style: "color:#eb2f96" };
    var formatter = {
      __vue_custom_formatter: true,
      header: function header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, "VueInstance"];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            ">"
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
            "<",
            formatValue(obj),
            (">" + (isReadonly(obj) ? " (readonly)" : ""))
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody: function hasBody(obj) {
        return obj && obj.__isVue;
      },
      body: function body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {} ].concat( formatInstance(obj.$)
          );
        }
      }
    };
    function formatInstance(instance) {
      var blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      var computed = extractKeys(instance, "computed");
      if (computed) {
        blocks.push(createInstanceBlock("computed", computed));
      }
      var injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type, target) {
      target = extend({}, target);
      if (!Object.keys(target).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          } ].concat( Object.keys(target).map(function (key) {
            return [
              "div",
              {},
              ["span", keywordStyle, key + ": "],
              formatValue(target[key], false)
            ];
          })
        )
      ];
    }
    function formatValue(v, asRaw) {
      if ( asRaw === void 0 ) asRaw = true;

      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type) {
      var Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      var extracted = {};
      for (var key in instance.ctx) {
        if (isKeyOfType(Comp, key, type)) {
          extracted[key] = instance.ctx[key];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key, type) {
      var opts = Comp[type];
      if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some(function (m) { return isKeyOfType(m, key, type); })) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (isShallow(v)) {
        return "ShallowRef";
      }
      if (v.effect) {
        return "ComputedRef";
      }
      return "Ref";
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter);
    } else {
      window.devtoolsFormatters = [formatter];
    }
  }
  var warn = !!(process.env.NODE_ENV !== "production") ? warn$1 : NOOP;
  !!(process.env.NODE_ENV !== "production") || true ? devtools$1 : void 0;
  !!(process.env.NODE_ENV !== "production") || true ? setDevtoolsHook$1 : NOOP;

  /**
  * @vue/runtime-dom v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  var vShowOriginalDisplay = Symbol("_vod");
  var vShowHidden = Symbol("_vsh");
  var vShow = {
    beforeMount: function beforeMount(el, ref, ref$1) {
      var value = ref.value;
      var transition = ref$1.transition;

      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted: function mounted(el, ref, ref$1) {
      var value = ref.value;
      var transition = ref$1.transition;

      if (transition && value) {
        transition.enter(el);
      }
    },
    updated: function updated(el, ref, ref$1) {
      var value = ref.value;
      var oldValue = ref.oldValue;
      var transition = ref$1.transition;

      if (!value === !oldValue) { return; }
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, function () {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount: function beforeUnmount(el, ref) {
      var value = ref.value;

      setDisplay(el, value);
    }
  };
  if (!!(process.env.NODE_ENV !== "production")) {
    vShow.name = "show";
  }
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }

  Symbol(!!(process.env.NODE_ENV !== "production") ? "CSS_VAR_TEXT" : "");

  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }

  var getModelAssigner = function (vnode) {
    var fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray(fn) ? function (value) { return invokeArrayFns(fn, value); } : fn;
  };
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    var target = e.target;
    if (target.composing) {
      target.composing = false;
      target.dispatchEvent(new Event("input"));
    }
  }
  var assignKey = Symbol("_assign");
  var vModelText = {
    created: function created(el, ref, vnode) {
      var ref_modifiers = ref.modifiers;
      var lazy = ref_modifiers.lazy;
      var trim = ref_modifiers.trim;
      var number = ref_modifiers.number;

      el[assignKey] = getModelAssigner(vnode);
      var castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", function (e) {
        if (e.target.composing) { return; }
        var domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", function () {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted: function mounted(el, ref) {
      var value = ref.value;

      el.value = value == null ? "" : value;
    },
    beforeUpdate: function beforeUpdate(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;
      var ref_modifiers = ref.modifiers;
      var lazy = ref_modifiers.lazy;
      var trim = ref_modifiers.trim;
      var number = ref_modifiers.number;

      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) { return; }
      var elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      var newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  var vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created: function created(el, _, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", function () {
        var modelValue = el._modelValue;
        var elementValue = getValue(el);
        var checked = el.checked;
        var assign = el[assignKey];
        if (isArray(modelValue)) {
          var index = looseIndexOf(modelValue, elementValue);
          var found = index !== -1;
          if (checked && !found) {
            assign(modelValue.concat(elementValue));
          } else if (!checked && found) {
            var filtered = [].concat( modelValue );
            filtered.splice(index, 1);
            assign(filtered);
          }
        } else if (isSet(modelValue)) {
          var cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign(cloned);
        } else {
          assign(getCheckboxValue(el, checked));
        }
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate: function beforeUpdate(el, binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    el._modelValue = value;
    if (isArray(value)) {
      el.checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      el.checked = value.has(vnode.props.value);
    } else if (value !== oldValue) {
      el.checked = looseEqual(value, getCheckboxValue(el, true));
    }
  }
  var vModelRadio = {
    created: function created(el, ref, vnode) {
      var value = ref.value;

      el.checked = looseEqual(value, vnode.props.value);
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", function () {
        el[assignKey](getValue(el));
      });
    },
    beforeUpdate: function beforeUpdate(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      el[assignKey] = getModelAssigner(vnode);
      if (value !== oldValue) {
        el.checked = looseEqual(value, vnode.props.value);
      }
    }
  };
  var vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created: function created(el, ref, vnode) {
      var value = ref.value;
      var number = ref.modifiers.number;

      var isSetModel = isSet(value);
      addEventListener(el, "change", function () {
        var selectedVal = Array.prototype.filter.call(el.options, function (o) { return o.selected; }).map(
          function (o) { return number ? looseToNumber(getValue(o)) : getValue(o); }
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(function () {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted: function mounted(el, ref) {
      var value = ref.value;
      ref.modifiers.number;

      setSelected(el, value);
    },
    beforeUpdate: function beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated: function updated(el, ref) {
      var value = ref.value;
      ref.modifiers.number;

      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value, number) {
    var isMultiple = el.multiple;
    var isArrayValue = isArray(value);
    if (isMultiple && !isArrayValue && !isSet(value)) {
      !!(process.env.NODE_ENV !== "production") && warn(
        ("<select multiple v-model> expects an Array or Set value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)) + ".")
      );
      return;
    }
    var loop = function ( i, l ) {
      var option = el.options[i];
      var optionValue = getValue(option);
      if (isMultiple) {
        if (isArrayValue) {
          var optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some(function (v) { return String(v) === String(optionValue); });
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) { el.selectedIndex = i; }
        return {};
      }
    };

    for (var i = 0, l = el.options.length; i < l; i++) {
      var returned = loop( i);

      if ( returned ) return returned.v;
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    var key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  var vModelDynamic = {
    created: function created(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "created");
    },
    mounted: function mounted(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate: function beforeUpdate(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated: function updated(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "updated");
    }
  };
  function resolveDynamicModel(tagName, type) {
    switch (tagName) {
      case "SELECT":
        return vModelSelect;
      case "TEXTAREA":
        return vModelText;
      default:
        switch (type) {
          case "checkbox":
            return vModelCheckbox;
          case "radio":
            return vModelRadio;
          default:
            return vModelText;
        }
    }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    var modelToUse = resolveDynamicModel(
      el.tagName,
      vnode.props && vnode.props.type
    );
    var fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
  }

  var systemModifiers = ["ctrl", "shift", "alt", "meta"];
  var modifierGuards = {
    stop: function (e) { return e.stopPropagation(); },
    prevent: function (e) { return e.preventDefault(); },
    self: function (e) { return e.target !== e.currentTarget; },
    ctrl: function (e) { return !e.ctrlKey; },
    shift: function (e) { return !e.shiftKey; },
    alt: function (e) { return !e.altKey; },
    meta: function (e) { return !e.metaKey; },
    left: function (e) { return "button" in e && e.button !== 0; },
    middle: function (e) { return "button" in e && e.button !== 1; },
    right: function (e) { return "button" in e && e.button !== 2; },
    exact: function (e, modifiers) { return systemModifiers.some(function (m) { return e[(m + "Key")] && !modifiers.includes(m); }); }
  };
  var withModifiers = function (fn, modifiers) {
    var cache = fn._withMods || (fn._withMods = {});
    var cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = function (event) {
      var args = [], len = arguments.length - 1;
      while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

      for (var i = 0; i < modifiers.length; i++) {
        var guard = modifierGuards[modifiers[i]];
        if (guard && guard(event, modifiers)) { return; }
      }
      return fn.apply(void 0, [ event ].concat( args ));
    });
  };
  var keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  var withKeys = function (fn, modifiers) {
    var cache = fn._withKeys || (fn._withKeys = {});
    var cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = function (event) {
      if (!("key" in event)) {
        return;
      }
      var eventKey = hyphenate(event.key);
      if (modifiers.some(function (k) { return k === eventKey || keyNames[k] === eventKey; })) {
        return fn(event);
      }
    });
  };

  /**
  * vue v3.4.38
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/

  function initDev() {
    {
      initCustomFormatter();
    }
  }

  if (!!(process.env.NODE_ENV !== "production")) {
    initDev();
  }

  function render$l(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSchema = resolveComponent("FormulateSchema");
    var _component_FormulateErrors = resolveComponent("FormulateErrors");

    return (openBlock(), createElementBlock("form", mergeProps({
      class: $options.classes.form
    }, $options.attributes, {
      onSubmit: _cache[0] || (_cache[0] = withModifiers(function () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

        return ($options.formSubmitted && $options.formSubmitted.apply($options, args));
    }, ["prevent"]))
    }), [
      ($props.schema)
        ? (openBlock(), createBlock(_component_FormulateSchema, mergeProps({
            key: 0,
            schema: $props.schema
          }, toHandlers($options.schemaListeners)), null, 16 /* FULL_PROPS */, ["schema"]))
        : createCommentVNode("v-if", true),
      (!$options.hasFormErrorObservers)
        ? (openBlock(), createBlock(_component_FormulateErrors, {
            key: 1,
            context: $options.formContext
          }, null, 8 /* PROPS */, ["context"]))
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps($options.formContext)))
    ], 16 /* FULL_PROPS */))
  }

  script$l.render = render$l;
  script$l.__file = "src/FormulateForm.vue";

  function objectWithoutProperties$1 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  /**
   * For a single instance of an input, export all of the context needed to fully
   * render that element.
   * @return {object}
   */
  var context = {
    context: function context () {
      return defineModel.call(this, Object.assign({}, {addLabel: this.logicalAddLabel,
        removeLabel: this.logicalRemoveLabel,
        attributes: this.elementAttributes,
        blurHandler: blurHandler.bind(this),
        classification: this.classification,
        component: this.component,
        debounceDelay: this.debounceDelay,
        disableErrors: this.disableErrors,
        errors: this.explicitErrors,
        formShouldShowErrors: this.formShouldShowErrors,
        getValidationErrors: this.getValidationErrors.bind(this),
        groupErrors: this.mergedGroupErrors,
        hasGivenName: this.hasGivenName,
        hasValue: this.hasValue,
        hasLabel: (this.label && this.classification !== 'button'),
        hasValidationErrors: this.hasValidationErrors.bind(this),
        help: this.help,
        helpPosition: this.logicalHelpPosition,
        id: this.id || this.defaultId,
        ignored: has$1(this.$options.propsData, 'ignored'),
        isValid: this.isValid,
        imageBehavior: this.imageBehavior,
        label: this.label,
        labelPosition: this.logicalLabelPosition,
        limit: this.limit === Infinity ? this.limit : parseInt(this.limit, 10),
        name: this.nameOrFallback,
        minimum: parseInt(this.minimum, 10),
        performValidation: this.performValidation.bind(this),
        pseudoProps: this.pseudoProps,
        preventWindowDrops: this.preventWindowDrops,
        removePosition: this.mergedRemovePosition,
        repeatable: this.repeatable,
        rootEmit: this.$emit.bind(this),
        rules: this.ruleDetails,
        setErrors: this.setErrors.bind(this),
        showValidationErrors: this.showValidationErrors,
        slotComponents: this.slotComponents,
        slotProps: this.slotProps,
        type: this.type,
        uploadBehavior: this.uploadBehavior,
        uploadUrl: this.mergedUploadUrl,
        uploader: this.uploader || this.$formulate.getUploader(),
        validationErrors: this.validationErrors,
        value: this.value,
        visibleValidationErrors: this.visibleValidationErrors,
        isSubField: this.isSubField,
        classes: this.classes},
        this.typeContext))
    },
    // Used in context
    nameOrFallback: nameOrFallback,
    hasGivenName: hasGivenName,
    typeContext: typeContext,
    elementAttributes: elementAttributes,
    logicalLabelPosition: logicalLabelPosition,
    logicalHelpPosition: logicalHelpPosition,
    mergedRemovePosition: mergedRemovePosition,
    mergedUploadUrl: mergedUploadUrl,
    mergedGroupErrors: mergedGroupErrors,
    hasValue: hasValue,
    visibleValidationErrors: visibleValidationErrors,
    slotComponents: slotComponents,
    logicalAddLabel: logicalAddLabel,
    logicalRemoveLabel: logicalRemoveLabel,
    classes: classes,
    showValidationErrors: showValidationErrors,
    slotProps: slotProps,
    pseudoProps: pseudoProps,
    isValid: isValid,
    ruleDetails: ruleDetails,

    // Not used in context
    isVmodeled: isVmodeled,
    mergedValidationName: mergedValidationName,
    explicitErrors: explicitErrors,
    allErrors: allErrors,
    hasVisibleErrors: hasVisibleErrors,
    hasErrors: hasErrors,
    filteredAttributes: filteredAttributes,
    typeProps: typeProps,
    listeners: listeners
  };

  /**
   * The label to display when adding a new group.
   */
  function logicalAddLabel () {
    if (this.classification === 'file') {
      return this.addLabel === true ? ("+ Add " + (cap(this.type))) : this.addLabel
    }
    if (typeof this.addLabel === 'boolean') {
      var label = this.label || this.name;
      return ("+ " + (typeof label === 'string' ? label + ' ' : '') + " Add")
    }
    return this.addLabel
  }
  /**
   * The label to display when removing a group.
   */
  function logicalRemoveLabel () {
    if (typeof this.removeLabel === 'boolean') {
      return 'Remove'
    }
    return this.removeLabel
  }

  /**
   * Given (this.type), return an object to merge with the context
   * @return {object}
   * @return {object}
   */
  function typeContext () {
    var this$1$1 = this;

    switch (this.classification) {
      case 'select':
        return {
          options: createOptionList.call(this, this.options),
          optionGroups: this.optionGroups ? map$1(this.optionGroups, function (k, v) { return createOptionList.call(this$1$1, v); }) : false,
          placeholder: this.$attrs.placeholder || false
        }
      case 'slider':
        return { showValue: !!this.showValue }
      default:
        if (this.options) {
          return {
            options: createOptionList.call(this, this.options)
          }
        }
        return {}
    }
  }

  /**
   * Items in $attrs that are better described as props.
   */
  function pseudoProps () {
    // Remove any "class key props" from the attributes.
    return extractAttributes(this.localAttributes, classProps)
  }

  /**
   * Remove props that are defined as slot props.
   */
  function typeProps () {
    return extractAttributes(this.localAttributes, this.$formulate.typeProps(this.type))
  }

  /**
   * Attributes with pseudoProps filtered out.
   */
  function filteredAttributes () {
    var this$1$1 = this;

    var filterKeys = Object.keys(this.pseudoProps)
      .concat(Object.keys(this.typeProps));
    return Object.keys(this.localAttributes).reduce(function (props, key) {
      if (!filterKeys.includes(camel(key))) {
        props[key] = this$1$1.localAttributes[key];
      }
      return props
    }, {})
  }

  /**
   * Reducer for attributes that will be applied to each core input element.
   * @return {object}
   */
  function elementAttributes () {
    var attrs = Object.assign({}, this.filteredAttributes);
    // pass the ID prop through to the root element
    if (this.id) {
      attrs.id = this.id;
    } else {
      attrs.id = this.defaultId;
    }
    // pass an explicitly given name prop through to the root element
    if (this.hasGivenName) {
      attrs.name = this.name;
    }

    // If there is help text, have this element be described by it.
    if (this.help && !has$1(attrs, 'aria-describedby')) {
      attrs['aria-describedby'] = (attrs.id) + "-help";
    }

    // Ensure we dont have a class attribute unless we are actually applying classes.
    if (this.classes.input && (!Array.isArray(this.classes.input) || this.classes.input.length)) {
      attrs.class = this.classes.input;
    }

    // @todo Filter out "local props" for custom inputs.

    return attrs
  }

  /**
   * Apply the result of the classes computed prop to any existing prop classes.
   */
  function classes () {
    return this.$formulate.classes(Object.assign({}, this.$props,
      this.pseudoProps,
      {attrs: this.filteredAttributes,
        classification: this.classification,
        hasErrors: this.hasVisibleErrors,
        hasValue: this.hasValue,
        helpPosition: this.logicalHelpPosition,
        isValid: this.isValid,
        labelPosition: this.logicalLabelPosition,
        type: this.type,
        value: this.proxy}))
  }

  /**
   * Determine the best-guess location for the label (before or after).
   * @return {string} before|after
   */
  function logicalLabelPosition () {
    if (this.labelPosition) {
      return this.labelPosition
    }
    switch (this.classification) {
      case 'box':
        return 'after'
      default:
        return 'before'
    }
  }

  /**
   * Determine the best location for the label based on type (before or after).
   */
  function logicalHelpPosition () {
    if (this.helpPosition) {
      return this.helpPosition
    }
    switch (this.classification) {
      case 'group':
        return 'before'
      default:
        return 'after'
    }
  }

  /**
   * Set remove button position for repeatable inputs
   */
  function mergedRemovePosition () {
    return (this.type === 'group') ? this.removePosition || 'before' : false
  }

  /**
   * The validation label to use.
   */
  function mergedValidationName () {
    var this$1$1 = this;

    var strategy = this.$formulate.options.validationNameStrategy || ['validationName', 'name', 'label', 'type'];
    if (Array.isArray(strategy)) {
      var key = strategy.find(function (key) { return typeof this$1$1[key] === 'string'; });
      return this[key]
    }
    if (typeof strategy === 'function') {
      return strategy.call(this, this)
    }
    return this.type
  }

  /**
   * Use the uploadURL on the input if it exists, otherwise use the uploadURL
   * that is defined as a plugin option.
   */
  function mergedUploadUrl () {
    return this.uploadUrl || this.$formulate.getUploadUrl()
  }

  /**
   * Merge localGroupErrors and groupErrors props.
   */
  function mergedGroupErrors () {
    var this$1$1 = this;

    var keys = Object.keys(this.groupErrors).concat(Object.keys(this.localGroupErrors));
    var isGroup = /^(\d+)\.(.*)$/;
    // Using new Set() to remove duplicates.
    return Array.from(new Set(keys))
      .filter(function (k) { return isGroup.test(k); })
      .reduce(function (groupErrors, fieldKey) {
        var obj;

        var ref = fieldKey.match(isGroup);
        var index = ref[1];
        var subField = ref[2];
        if (!has$1(groupErrors, index)) {
          groupErrors[index] = {};
        }
        var fieldErrors = Array.from(new Set(
          arrayify(this$1$1.groupErrors[fieldKey]).concat(arrayify(this$1$1.localGroupErrors[fieldKey]))
        ));
        groupErrors[index] = Object.assign(groupErrors[index], ( obj = {}, obj[subField] = fieldErrors, obj ));
        return groupErrors
      }, {})
  }

  /**
   * Takes the parsed validation rules and makes them a bit more readable.
   */
  function ruleDetails () {
    return this.parsedValidation
      .map(function (ref) {
        var args = ref[1];
        var ruleName = ref[2];

        return ({ ruleName: ruleName, args: args });
    })
  }

  /**
   * Determines if the field should show it's error (if it has one)
   * @return {boolean}
   */
  function showValidationErrors () {
    if (this.showErrors || this.formShouldShowErrors) {
      return true
    }
    if (this.classification === 'file' && this.uploadBehavior === 'live' && modelGetter.call(this)) {
      return true
    }
    return this.behavioralErrorVisibility
  }

  /**
   * All of the currently visible validation errors (does not include error handling)
   * @return {array}
   */
  function visibleValidationErrors () {
    return (this.showValidationErrors && this.validationErrors.length) ? this.validationErrors : []
  }

  /**
   * Return the element’s name, or select a fallback.
   */
  function nameOrFallback () {
    if (this.name === true && this.classification !== 'button') {
      var id = this.id || this.elementAttributes.id.replace(/[^0-9]/g, '');
      return ((this.type) + "_" + id)
    }
    if (this.name === false || (this.classification === 'button' && this.name === true)) {
      return false
    }
    return this.name
  }

  /**
   * determine if an input has a user-defined name
   */
  function hasGivenName () {
    return typeof this.name !== 'boolean'
  }

  /**
   * Determines if the current input has a value or not. To do this we need to
   * check for various falsey values. But we cannot assume that all falsey values
   * mean an empty or unselected field (for example 0) and we cant assume that
   * all truthy values are empty like [] or {}.
   */
  function hasValue () {
    var this$1$1 = this;

    var value = this.proxy;
    if (
      (this.classification === 'box' && this.isGrouped) ||
      (this.classification === 'select' && has$1(this.filteredAttributes, 'multiple'))
    ) {
      return Array.isArray(value) ? value.some(function (v) { return v === this$1$1.value; }) : this.value === value
    }
    return !isEmpty(value)
  }

  /**
   * Determines if this formulate element is v-modeled or not.
   */
  function isVmodeled () {
    return !!(this.$options.propsData.hasOwnProperty('formulateValue') &&
      this._events &&
      Array.isArray(this._events.input) &&
      this._events.input.length)
  }

  /**
   * Given an object or array of options, create an array of objects with label,
   * value, and id.
   * @param {array|object}
   * @return {array}
   */
  function createOptionList (optionData) {
    if (!optionData) {
      return []
    }
    var options = Array.isArray(optionData) ? optionData : Object.keys(optionData).map(function (value) { return ({ label: optionData[value], value: value }); });
    return options.map(createOption.bind(this))
  }

  /**
   * Given a wide ranging input (string, object, etc) return an option item
   * @param {typeof} option
   */
  function createOption (option) {
    // Numbers are not allowed
    if (typeof option === 'number') {
      option = String(option);
    }
    if (typeof option === 'string') {
      return { label: option, value: option, id: ((this.elementAttributes.id) + "_" + option) }
    }
    if (typeof option.value === 'number') {
      option.value = String(option.value);
    }
    return Object.assign({
      value: '',
      label: '',
      id: ((this.elementAttributes.id) + "_" + (option.value || option.label))
    }, option)
  }

  /**
   * These are errors we that have been explicity passed to us.
   */
  function explicitErrors () {
    return arrayify(this.errors)
      .concat(this.localErrors)
      .concat(arrayify(this.error))
  }

  /**
   * The merged errors computed property.
   */
  function allErrors () {
    return this.explicitErrors
      .concat(arrayify(this.validationErrors))
  }

  /**
   * Does this computed property have errors
   */
  function hasErrors () {
    return !!this.allErrors.length
  }

  /**
   * True when the field has no errors at all.
   */
  function isValid () {
    return !this.hasErrors
  }

  /**
   * Returns if form has actively visible errors (of any kind)
   */
  function hasVisibleErrors () {
    return (
      (Array.isArray(this.validationErrors) && this.validationErrors.length && this.showValidationErrors) ||
      !!this.explicitErrors.length
    )
  }

  /**
   * The component that should be rendered in the label slot as default.
   */
  function slotComponents () {
    var fn = this.$formulate.slotComponent.bind(this.$formulate);
    return {
      addMore: fn(this.type, 'addMore'),
      buttonContent: fn(this.type, 'buttonContent'),
      errors: fn(this.type, 'errors'),
      file: fn(this.type, 'file'),
      help: fn(this.type, 'help'),
      label: fn(this.type, 'label'),
      prefix: fn(this.type, 'prefix'),
      remove: fn(this.type, 'remove'),
      repeatable: fn(this.type, 'repeatable'),
      suffix: fn(this.type, 'suffix'),
      uploadAreaMask: fn(this.type, 'uploadAreaMask')
    }
  }

  /**
   * Any extra props to pass to slot components.
   */
  function slotProps () {
    var fn = this.$formulate.slotProps.bind(this.$formulate);
    return {
      label: fn(this.type, 'label', this.typeProps),
      help: fn(this.type, 'help', this.typeProps),
      errors: fn(this.type, 'errors', this.typeProps),
      repeatable: fn(this.type, 'repeatable', this.typeProps),
      addMore: fn(this.type, 'addMore', this.typeProps),
      remove: fn(this.type, 'remove', this.typeProps),
      component: fn(this.type, 'component', this.typeProps)
    }
  }

  /**
   * Bound into the context object.
   */
  function blurHandler () {
    var this$1$1 = this;

    if (this.errorBehavior === 'blur' || this.errorBehavior === 'value') {
      this.behavioralErrorVisibility = true;
    }
    this.$nextTick(function () { return this$1$1.$emit('blur-context', this$1$1.context); });
  }

  /**
   * Bound listeners.
   */
  function listeners () {
    var ref = this.$listeners;
    ref.input;
    var rest = objectWithoutProperties$1( ref, ["input"] );
    var listeners = rest;
    return listeners
  }

  /**
   * Defines the model used throughout the existing context.
   * @param {object} context
   */
  function defineModel (context) {
    var this$1$1 = this;

    return Object.defineProperty(context, 'model', {
      get: modelGetter.bind(this),
      set: function (value) {
        if (!this$1$1.mntd || !this$1$1.debounceDelay) {
          return modelSetter.call(this$1$1, value)
        }
        this$1$1.dSet(modelSetter, [value], this$1$1.debounceDelay);
      },
      enumerable: true
    })
  }

  /**
   * Get the value from a model.
   **/
  function modelGetter () {
    var model = this.isVmodeled ? 'formulateValue' : 'proxy';
    if (this.type === 'checkbox' && !Array.isArray(this[model]) && this.options) {
      return []
    }
    if (!this[model] && this[model] !== 0) {
      return ''
    }
    return this[model]
  }

  /**
   * Set the value from a model.
   **/
  function modelSetter (value) {
    var didUpdate = false;
    if (!equals(value, this.proxy, this.type === 'group')) {
      this.proxy = value;
      didUpdate = true;
    }
    if (!this.context.ignored && this.context.name && typeof this.formulateSetter === 'function') {
      this.formulateSetter(this.context.name, value);
    }
    if (didUpdate) {
      this.$emit('input', value);
    }
  }

  var script$k = {
    name: 'FormulateInput',
    inheritAttrs: false,
    provide: function provide () {
      return {
        // Allows sub-components of this input to register arbitrary rules.
        formulateRegisterRule: this.registerRule,
        formulateRemoveRule: this.removeRule
      }
    },
    inject: {
      formulateSetter: { default: undefined },
      formulateFieldValidation: { default: function () { return function () { return ({}); }; } },
      formulateRegister: { default: undefined },
      formulateDeregister: { default: undefined },
      getFormValues: { default: function () { return function () { return ({}); }; } },
      getGroupValues: { default: undefined },
      validateDependents: { default: function () { return function () {}; } },
      observeErrors: { default: undefined },
      removeErrorObserver: { default: undefined },
      isSubField: { default: function () { return function () { return false; }; } }
    },
    model: {
      prop: 'formulateValue',
      event: 'input'
    },
    props: {
      type: {
        type: String,
        default: 'text'
      },
      name: {
        type: [String, Boolean],
        default: true
      },
      /* eslint-disable */
      formulateValue: {
        default: ''
      },
      value: {
        default: false
      },
      /* eslint-enable */
      options: {
        type: [Object, Array, Boolean],
        default: false
      },
      optionGroups: {
        type: [Object, Boolean],
        default: false
      },
      id: {
        type: [String, Boolean, Number],
        default: false
      },
      label: {
        type: [String, Boolean],
        default: false
      },
      labelPosition: {
        type: [String, Boolean],
        default: false
      },
      limit: {
        type: [String, Number],
        default: Infinity,
        validator: function (value) { return Infinity || parseInt(value, 10) == value; } // eslint-disable-line eqeqeq
      },
      minimum: {
        type: [String, Number],
        default: 0,
        validator: function (value) { return parseInt(value, 10) == value; } // eslint-disable-line eqeqeq
      },
      help: {
        type: [String, Boolean],
        default: false
      },
      helpPosition: {
        type: [String, Boolean],
        default: false
      },
      isGrouped: {
        type: Boolean,
        default: false
      },
      errors: {
        type: [String, Array, Boolean],
        default: false
      },
      removePosition: {
        type: [String, Boolean],
        default: false
      },
      repeatable: {
        type: Boolean,
        default: false
      },
      validation: {
        type: [String, Boolean, Array],
        default: false
      },
      validationName: {
        type: [String, Boolean],
        default: false
      },
      error: {
        type: [String, Boolean],
        default: false
      },
      errorBehavior: {
        type: String,
        default: 'blur',
        validator: function (value) {
          return ['blur', 'live', 'submit', 'value'].includes(value)
        }
      },
      showErrors: {
        type: Boolean,
        default: false
      },
      groupErrors: {
        type: Object,
        default: function () { return ({}); },
        validator: function (value) {
          var isK = /^\d+\./;
          return !Object.keys(value).some(function (k) { return !isK.test(k); })
        }
      },
      imageBehavior: {
        type: String,
        default: 'preview'
      },
      uploadUrl: {
        type: [String, Boolean],
        default: false
      },
      uploader: {
        type: [Function, Object, Boolean],
        default: false
      },
      uploadBehavior: {
        type: String,
        default: 'live'
      },
      preventWindowDrops: {
        type: Boolean,
        default: true
      },
      showValue: {
        type: [String, Boolean],
        default: false
      },
      validationMessages: {
        type: Object,
        default: function () { return ({}); }
      },
      validationRules: {
        type: Object,
        default: function () { return ({}); }
      },
      checked: {
        type: [String, Boolean],
        default: false
      },
      disableErrors: {
        type: Boolean,
        default: false
      },
      addLabel: {
        type: [Boolean, String],
        default: true
      },
      removeLabel: {
        type: [Boolean, String],
        default: false
      },
      keepModelData: {
        type: [Boolean, String],
        default: 'inherit'
      },
      ignored: {
        type: [Boolean, String],
        default: false
      },
      debounce: {
        type: [Boolean, Number],
        default: false
      },
      preventDeregister: {
        type: Boolean,
        default: false
      }
    },
    data: function data () {
      return {
        defaultId: this.$formulate.nextId(this),
        localAttributes: {},
        localErrors: [],
        localGroupErrors: {},
        proxy: this.getInitialValue(),
        behavioralErrorVisibility: (this.errorBehavior === 'live'),
        formShouldShowErrors: false,
        validationErrors: [],
        pendingValidation: Promise.resolve(),
        // These registries are used for injected messages registrants only (mostly internal).
        ruleRegistry: [],
        messageRegistry: {},
        touched: false,
        debounceDelay: this.debounce,
        dSet: createDebouncer(),
        mntd: false
      }
    },
    computed: Object.assign({}, context,
      {classification: function classification () {
        var classification = this.$formulate.classify(this.type);
        return (classification === 'box' && this.options) ? 'group' : classification
      },
      component: function component () {
        return (this.classification === 'group') ? 'FormulateInputGroup' : this.$formulate.component(this.type)
      },
      parsedValidationRules: function parsedValidationRules () {
        var this$1$1 = this;

        var parsedValidationRules = {};
        Object.keys(this.validationRules).forEach(function (key) {
          parsedValidationRules[camel(key)] = this$1$1.validationRules[key];
        });
        return parsedValidationRules
      },
      parsedValidation: function parsedValidation () {
        return parseRules(this.validation, this.$formulate.rules(this.parsedValidationRules))
      },
      messages: function messages () {
        var this$1$1 = this;

        var messages = {};
        Object.keys(this.validationMessages).forEach(function (key) {
          messages[camel(key)] = this$1$1.validationMessages[key];
        });
        Object.keys(this.messageRegistry).forEach(function (key) {
          messages[camel(key)] = this$1$1.messageRegistry[key];
        });
        return messages
      }}),
    watch: {
      '$attrs': {
        handler: function handler (value) {
          this.updateLocalAttributes(value);
        },
        deep: true
      },
      proxy: {
        handler: function (newValue, oldValue) {
          this.performValidation();
          if (!this.isVmodeled && !equals(newValue, oldValue, this.type === 'group')) {
            this.context.model = newValue;
          }
          this.validateDependents(this);
          if (!this.touched && newValue) {
            this.touched = true;
          }
        },
        deep: true
      },
      formulateValue: {
        handler: function (newValue, oldValue) {
          if (this.isVmodeled && !equals(newValue, oldValue, this.type === 'group')) {
            this.context.model = newValue;
          }
        },
        deep: true
      },
      showValidationErrors: {
        handler: function handler (val) {
          this.$emit('error-visibility', val);
        },
        immediate: true
      },
      validation: {
        handler: function handler () {
          this.performValidation();
        },
        deep: true
      },
      touched: function touched (value) {
        if (this.errorBehavior === 'value' && value) {
          this.behavioralErrorVisibility = value;
        }
      },
      debounce: function debounce (value) {
        this.debounceDelay = value;
      }
    },
    created: function created () {
      this.applyInitialValue();
      if (this.formulateRegister && typeof this.formulateRegister === 'function') {
        this.formulateRegister(this.nameOrFallback, this);
      }
      this.applyDefaultValue();
      if (!this.disableErrors && typeof this.observeErrors === 'function') {
        this.observeErrors({ callback: this.setErrors, type: 'input', field: this.nameOrFallback });
        if (this.type === 'group') {
          this.observeErrors({ callback: this.setGroupErrors, type: 'group', field: this.nameOrFallback });
        }
      }
      this.updateLocalAttributes(this.$attrs);
      this.performValidation();
      if (this.hasValue) {
        this.touched = true;
      }
    },
    mounted: function mounted () {
      this.mntd = true;
    },
    beforeDestroy: function beforeDestroy () {
      if (!this.disableErrors && typeof this.removeErrorObserver === 'function') {
        this.removeErrorObserver(this.setErrors);
        if (this.type === 'group') {
          this.removeErrorObserver(this.setGroupErrors);
        }
      }
      if (typeof this.formulateDeregister === 'function' && !this.preventDeregister) {
        this.formulateDeregister(this.nameOrFallback);
      }
    },
    methods: {
      getInitialValue: function getInitialValue () {
        // Manually request classification, pre-computed props
        var classification = this.$formulate.classify(this.type);
        classification = (classification === 'box' && this.options) ? 'group' : classification;
        if (classification === 'box' && this.checked) {
          return this.value || true
        } else if (has$1(this.$options.propsData, 'value') && classification !== 'box') {
          return this.value
        } else if (has$1(this.$options.propsData, 'formulateValue')) {
          return this.formulateValue
        } else if (classification === 'group') {
          // Set the value of an empty group
          return Object.defineProperty(this.type === 'group' ? [{}] : [], '__init', { value: true })
        }
        return ''
      },
      applyInitialValue: function applyInitialValue () {
        // This should only be run immediately on created and ensures that the
        // proxy and the model are both the same before any additional registration.
        if (
          !equals(this.context.model, this.proxy) &&
          // we dont' want to set the model if we are a sub-box of a multi-box field
          (this.classification !== 'box' || has$1(this.$options.propsData, 'options'))
        ) {
          this.context.model = this.proxy;
          this.$emit('input', this.proxy);
        }
      },
      applyDefaultValue: function applyDefaultValue () {
        // Some inputs have may have special logic determining what to do if they
        // are still strictly undefined after applyInitialValue and registration.
        if (
          this.type === 'select' &&
          !this.context.placeholder &&
          isEmpty(this.proxy) &&
          !this.isVmodeled &&
          this.value === false &&
          this.context.options.length
        ) {
          if (!has$1(this.$attrs, 'multiple')) {
            // In this condition we have a blank select input with no value, by
            // default HTML will select the first element, so we emulate that.
            // See https://github.com/wearebraid/vue-formulate/issues/165
            this.context.model = this.context.options[0].value;
          } else {
            // In this condition we have a multi select input, which should use
            // an array as it's v-model base state.
            this.context.model = [];
          }
        }
      },
      updateLocalAttributes: function updateLocalAttributes (value) {
        if (!equals(value, this.localAttributes)) {
          this.localAttributes = value;
        }
      },
      performValidation: function performValidation () {
        var this$1$1 = this;

        var rules = parseRules(this.validation, this.$formulate.rules(this.parsedValidationRules));
        // Add in ruleRegistry rules. These are added directly via injection from
        // children and not part of the standard validation rule set.
        rules = this.ruleRegistry.length ? this.ruleRegistry.concat(rules) : rules;
        this.pendingValidation = this.runRules(rules)
          .then(function (messages) { return this$1$1.didValidate(messages); });
        return this.pendingValidation
      },
      runRules: function runRules (rules) {
        var this$1$1 = this;

        var run = function (ref) {
          var rule = ref[0];
          var args = ref[1];
          var ruleName = ref[2];
          ref[3];

          var res = rule.apply(void 0, [ {
            value: this$1$1.context.model,
            getFormValues: function () {
              var ref;

              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
              return (ref = this$1$1).getFormValues.apply(ref, [ this$1$1 ].concat( args ));
          },
            getGroupValues: function () {
              var ref;

              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
              return (ref = this$1$1)[("get" + (this$1$1.getGroupValues ? 'Group' : 'Form') + "Values")].apply(ref, [ this$1$1 ].concat( args ));
          },
            name: this$1$1.context.name
          } ].concat( args ));
          res = (res instanceof Promise) ? res : Promise.resolve(res);
          return res.then(function (result) { return result ? false : this$1$1.getMessage(ruleName, args); })
        };

        return new Promise(function (resolve) {
          // We break our rules into resolvable groups. These groups are
          // adjacent rules that can be resolved simultaneously. For example
          // consider: required|min:6,length here both rules resolve in parallel.
          // but ^required|min:6,length cannot be resolved in parallel because
          // the execution of the min rule requires passing resolution of the
          // required rule due to bailing. `resolveGroups` runs/resolves each of
          // these resolution groups, while `groupBails` is responsible for
          // producing them.
          var resolveGroups = function (groups, allMessages) {
            if ( allMessages === void 0 ) allMessages = [];

            var ruleGroup = groups.shift();
            if (Array.isArray(ruleGroup) && ruleGroup.length) {
              Promise.all(ruleGroup.map(run))
                // Filter out any simple falsy values to prevent triggering errors
                .then(function (messages) { return messages.filter(function (m) { return !!m; }); })
                .then(function (messages) {
                  messages = Array.isArray(messages) ? messages : [];
                  // The rule passed or its a non-bailing group, and there are additional groups to check, continue
                  if ((!messages.length || !ruleGroup.bail) && groups.length) {
                    return resolveGroups(groups, allMessages.concat(messages))
                  }
                  // Filter out any empty error messages, this is important for
                  // the `optional` rule. It uses a hard-coded empty array [] as
                  // the message to trigger bailing, but we obviously don’t want
                  // this message to make it out of this resolver.
                  return resolve(allMessages.concat(messages).filter(function (m) { return !isEmpty(m); }))
                });
            } else {
              resolve([]);
            }
          };
          // Produce our resolution groups, and then run them
          resolveGroups(groupBails(rules));
        })
      },
      didValidate: function didValidate (messages) {
        var validationChanged = !equals(messages, this.validationErrors);
        this.validationErrors = messages;
        if (validationChanged) {
          var errorObject = this.getErrorObject();
          this.$emit('validation', errorObject);
          if (this.formulateFieldValidation && typeof this.formulateFieldValidation === 'function') {
            this.formulateFieldValidation(errorObject);
          }
        }
      },
      getMessage: function getMessage (ruleName, args) {
        var this$1$1 = this;

        return this.getMessageFunc(ruleName)({
          args: args,
          name: this.mergedValidationName,
          value: this.context.model,
          vm: this,
          formValues: this.getFormValues(this),
          getFormValues: function () {
            var ref;

            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
            return (ref = this$1$1).getFormValues.apply(ref, [ this$1$1 ].concat( args ));
        },
          getGroupValues: function () {
            var ref;

            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
            return (ref = this$1$1)[("get" + (this$1$1.getGroupValues ? 'Group' : 'Form') + "Values")].apply(ref, [ this$1$1 ].concat( args ));
        }
        })
      },
      getMessageFunc: function getMessageFunc (ruleName) {
        var this$1$1 = this;

        ruleName = camel(ruleName);
        if (ruleName === 'optional') {
          // Optional rules need to trigger bailing by having a message, but pass
          // the simple double bang (!!) filer, any non-string value will have
          // this effect.
          return function () { return ([]); }
        }
        if (this.messages && typeof this.messages[ruleName] !== 'undefined') {
          switch (typeof this.messages[ruleName]) {
            case 'function':
              return this.messages[ruleName]
            case 'string':
            case 'boolean':
              return function () { return this$1$1.messages[ruleName]; }
          }
        }
        return function (context) { return this$1$1.$formulate.validationMessage(ruleName, context, this$1$1); }
      },
      hasValidationErrors: function hasValidationErrors () {
        var this$1$1 = this;

        return new Promise(function (resolve) {
          this$1$1.$nextTick(function () {
            this$1$1.pendingValidation.then(function () { return resolve(!!this$1$1.validationErrors.length); });
          });
        })
      },
      getValidationErrors: function getValidationErrors () {
        var this$1$1 = this;

        return new Promise(function (resolve) {
          this$1$1.$nextTick(function () { return this$1$1.pendingValidation.then(function () { return resolve(this$1$1.getErrorObject()); }); });
        })
      },
      getErrorObject: function getErrorObject () {
        return {
          name: this.context.nameOrFallback || this.context.name,
          errors: this.validationErrors.filter(function (s) { return typeof s === 'string'; }),
          hasErrors: !!this.validationErrors.length
        }
      },
      setErrors: function setErrors (errors) {
        this.localErrors = arrayify(errors);
      },
      setGroupErrors: function setGroupErrors (groupErrors) {
        this.localGroupErrors = groupErrors;
      },
      registerRule: function registerRule (rule, args, ruleName, message) {
        if ( message === void 0 ) message = null;

        if (!this.ruleRegistry.some(function (r) { return r[2] === ruleName; })) {
          // These are the raw rule format since they will be used directly.
          this.ruleRegistry.push([rule, args, ruleName]);
          if (message !== null) {
            this.messageRegistry[ruleName] = message;
          }
        }
      },
      removeRule: function removeRule (key) {
        var ruleIndex = this.ruleRegistry.findIndex(function (r) { return r[2] === key; });
        if (ruleIndex >= 0) {
          this.ruleRegistry.splice(ruleIndex, 1);
          delete this.messageRegistry[key];
        }
      }
    }
  };

  var _hoisted_1$e = ["data-classification", "data-has-errors", "data-is-showing-errors", "data-has-value", "data-type"];

  function render$k(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.outer),
      "data-classification": $options.classification,
      "data-has-errors": _ctx.hasErrors,
      "data-is-showing-errors": _ctx.hasVisibleErrors,
      "data-has-value": _ctx.hasValue,
      "data-type": $props.type
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.context.classes.wrapper)
      }, [
        (_ctx.context.labelPosition === 'before')
          ? renderSlot(_ctx.$slots, "label", normalizeProps(mergeProps({ key: 0 }, _ctx.context)), function () { return [
              (_ctx.context.hasLabel)
                ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.label), mergeProps({ key: 0 }, _ctx.context.slotProps.label, { context: _ctx.context }), null, 16 /* FULL_PROPS */, ["context"]))
                : createCommentVNode("v-if", true)
            ]; })
          : createCommentVNode("v-if", true),
        (_ctx.context.helpPosition === 'before')
          ? renderSlot(_ctx.$slots, "help", normalizeProps(mergeProps({ key: 1 }, _ctx.context)), function () { return [
              (_ctx.context.help)
                ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.help), mergeProps({ key: 0 }, _ctx.context.slotProps.help, { context: _ctx.context }), null, 16 /* FULL_PROPS */, ["context"]))
                : createCommentVNode("v-if", true)
            ]; })
          : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "element", normalizeProps(guardReactiveProps(_ctx.context)), function () { return [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.component), mergeProps({ context: _ctx.context }, _ctx.context.slotProps.component, toHandlers(_ctx.listeners)), {
            default: withCtx(function () { return [
              renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(_ctx.context)))
            ]; }),
            _: 3 /* FORWARDED */
          }, 16 /* FULL_PROPS */, ["context"]))
        ]; }),
        (_ctx.context.labelPosition === 'after')
          ? renderSlot(_ctx.$slots, "label", normalizeProps(mergeProps({ key: 2 }, _ctx.context)), function () { return [
              (_ctx.context.hasLabel)
                ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.label), mergeProps({
                    key: 0,
                    context: _ctx.context
                  }, _ctx.context.slotProps.label), null, 16 /* FULL_PROPS */, ["context"]))
                : createCommentVNode("v-if", true)
            ]; })
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */),
      (_ctx.context.helpPosition === 'after')
        ? renderSlot(_ctx.$slots, "help", normalizeProps(mergeProps({ key: 0 }, _ctx.context)), function () { return [
            (_ctx.context.help)
              ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.help), mergeProps({
                  key: 0,
                  context: _ctx.context
                }, _ctx.context.slotProps.help), null, 16 /* FULL_PROPS */, ["context"]))
              : createCommentVNode("v-if", true)
          ]; })
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "errors", normalizeProps(guardReactiveProps(_ctx.context)), function () { return [
        (!_ctx.context.disableErrors)
          ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.errors), mergeProps({
              key: 0,
              type: _ctx.context.slotComponents.errors === 'FormulateErrors' ? 'input' : false,
              context: _ctx.context
            }, _ctx.context.slotProps.errors), null, 16 /* FULL_PROPS */, ["type", "context"]))
          : createCommentVNode("v-if", true)
      ]; })
    ], 10 /* CLASS, PROPS */, _hoisted_1$e))
  }

  script$k.render = render$k;
  script$k.__file = "src/FormulateInput.vue";

  var script$j = {
    inject: {
      observeErrors: {
        default: false
      },
      removeErrorObserver: {
        default: false
      },
      observeContext: {
        default: false
      },
      removeContextObserver: {
        default: false
      }
    },
    props: {
      context: {
        type: Object,
        default: function () { return ({}); }
      },
      type: {
        type: String,
        default: 'form'
      }
    },
    data: function data () {
      return {
        boundSetErrors: this.setErrors.bind(this),
        boundSetFormContext: this.setFormContext.bind(this),
        localErrors: [],
        formContext: {
          classes: {
            formErrors: 'formulate-form-errors',
            formError: 'formulate-form-error'
          }
        }
      }
    },
    computed: {
      visibleValidationErrors: function visibleValidationErrors () {
        return Array.isArray(this.context.visibleValidationErrors) ? this.context.visibleValidationErrors : []
      },
      errors: function errors () {
        return Array.isArray(this.context.errors) ? this.context.errors : []
      },
      mergedErrors: function mergedErrors () {
        return this.errors.concat(this.localErrors)
      },
      visibleErrors: function visibleErrors () {
        return Array.from(new Set(this.mergedErrors.concat(this.visibleValidationErrors)))
          .filter(function (message) { return typeof message === 'string'; })
      },
      outerClass: function outerClass () {
        if (this.type === 'input' && this.context.classes) {
          return this.context.classes.errors
        }
        return this.formContext.classes.formErrors
      },
      itemClass: function itemClass () {
        if (this.type === 'input' && this.context.classes) {
          return this.context.classes.error
        }
        return this.formContext.classes.formError
      },
      role: function role () {
        return this.type === 'form' ? 'alert' : 'status'
      },
      ariaLive: function ariaLive () {
        return this.type === 'form' ? 'assertive' : 'polite'
      },
      slotComponent: function slotComponent () {
        return this.$formulate.slotComponent(null, 'errorList')
      }
    },
    created: function created () {
      // This registration is for <FormulateErrors /> that are used for displaying
      // Form errors in an override position.
      if (this.type === 'form' && typeof this.observeErrors === 'function') {
        if (!Array.isArray(this.context.errors)) {
          this.observeErrors({ callback: this.boundSetErrors, type: 'form' });
        }
        this.observeContext(this.boundSetFormContext);
      }
    },
    destroyed: function destroyed () {
      if (this.type === 'form' && typeof this.removeErrorObserver === 'function') {
        if (!Array.isArray(this.context.errors)) {
          this.removeErrorObserver(this.boundSetErrors);
        }
        this.removeContextObserver(this.boundSetFormContext);
      }
    },
    methods: {
      setErrors: function setErrors (errors) {
        this.localErrors = arrayify(errors);
      },
      setFormContext: function setFormContext (context) {
        this.formContext = context;
      }
    }
  };

  function render$j(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createBlock(resolveDynamicComponent($options.slotComponent), {
      "visible-errors": $options.visibleErrors,
      "item-class": $options.itemClass,
      "outer-class": $options.outerClass,
      role: $options.role,
      "aria-live": $options.ariaLive,
      type: $props.type
    }, null, 8 /* PROPS */, ["visible-errors", "item-class", "outer-class", "role", "aria-live", "type"]))
  }

  script$j.render = render$j;
  script$j.__file = "src/FormulateErrors.vue";

  var script$i = {
    props: {
      context: {
        type: Object,
        required: true
      }
    }
  };

  var _hoisted_1$d = ["id", "textContent"];

  function render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return ($props.context.help)
      ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: (($props.context.id) + "-help"),
          class: normalizeClass($props.context.classes.help),
          textContent: toDisplayString($props.context.help)
        }, null, 10 /* CLASS, PROPS */, _hoisted_1$d))
      : createCommentVNode("v-if", true)
  }

  script$i.render = render$i;
  script$i.__file = "src/slots/FormulateHelp.vue";

  var script$h = {
    props: {
      file: {
        type: Object,
        required: true
      },
      imagePreview: {
        type: Boolean,
        default: false
      },
      context: {
        type: Object,
        required: true
      }
    }
  };

  var _hoisted_1$c = ["src"];
  var _hoisted_2$7 = ["title", "textContent"];
  var _hoisted_3$4 = ["data-just-finished", "data-is-finished"];

  function render$h(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("div", {
      class: normalizeClass($props.context.classes.file)
    }, [
      (!!($props.imagePreview && $props.file.previewData))
        ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass($props.context.classes.fileImagePreview)
          }, [
            createBaseVNode("img", {
              src: $props.file.previewData,
              class: normalizeClass($props.context.classes.fileImagePreviewImage)
            }, null, 10 /* CLASS, PROPS */, _hoisted_1$c)
          ], 2 /* CLASS */))
        : createCommentVNode("v-if", true),
      createBaseVNode("div", {
        class: normalizeClass($props.context.classes.fileName),
        title: $props.file.name,
        textContent: toDisplayString($props.file.name)
      }, null, 10 /* CLASS, PROPS */, _hoisted_2$7),
      ($props.file.progress !== false)
        ? (openBlock(), createElementBlock("div", {
            key: 1,
            "data-just-finished": $props.file.justFinished,
            "data-is-finished": !$props.file.justFinished && $props.file.complete,
            class: normalizeClass($props.context.classes.fileProgress)
          }, [
            createBaseVNode("div", {
              class: normalizeClass($props.context.classes.fileProgressInner),
              style: normalizeStyle({width: $props.file.progress + '%'})
            }, null, 6 /* CLASS, STYLE */)
          ], 10 /* CLASS, PROPS */, _hoisted_3$4))
        : createCommentVNode("v-if", true),
      (($props.file.complete && !$props.file.justFinished) || $props.file.progress === false)
        ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass($props.context.classes.fileRemove),
            onClick: _cache[0] || (_cache[0] = function () {
              var ref;

              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
              return ($props.file.removeFile && (ref = $props.file).removeFile.apply(ref, args));
    })
          }, null, 2 /* CLASS */))
        : createCommentVNode("v-if", true)
    ], 2 /* CLASS */))
  }

  script$h.render = render$h;
  script$h.__file = "src/slots/FormulateFile.vue";

  var script$g = {
    name: 'FormulateGrouping',
    props: {
      context: {
        type: Object,
        required: true
      }
    },
    provide: function provide () {
      return {
        isSubField: function () { return true; },
        registerProvider: this.registerProvider,
        deregisterProvider: this.deregisterProvider
      }
    },
    data: function data () {
      return {
        providers: [],
        keys: []
      }
    },
    inject: ['formulateRegisterRule', 'formulateRemoveRule'],
    computed: {
      items: function items () {
        var this$1$1 = this;

        if (Array.isArray(this.context.model)) {
          if (!this.context.repeatable && this.context.model.length === 0) {
            // This is the default input.
            return [this.setId({}, 0)]
          }
          if (this.context.model.length < this.context.minimum) {
            return (new Array(this.context.minimum || 1)).fill('')
              .map(function (t, index) { return this$1$1.setId(this$1$1.context.model[index] || {}, index); })
          }
          return this.context.model.map(function (item, index) { return this$1$1.setId(item, index); })
        }
        // This is an unset group
        return (new Array(this.context.minimum || 1)).fill('').map(function (_i, index) { return this$1$1.setId({}, index); })
      },
      formShouldShowErrors: function formShouldShowErrors () {
        return this.context.formShouldShowErrors
      },
      groupErrors: function groupErrors () {
        var this$1$1 = this;

        return this.items
          .map(function (item, index) { return has$1(this$1$1.context.groupErrors, index) ? this$1$1.context.groupErrors[index] : {}; })
      }
    },
    watch: {
      providers: function providers () {
        if (this.formShouldShowErrors) {
          this.showErrors();
        }
      },
      formShouldShowErrors: function formShouldShowErrors (val) {
        if (val) {
          this.showErrors();
        }
      },
      items: {
        handler: function handler (items, oldItems) {
          if (!equals(items, oldItems, true)) {
            this.keys = items.map(function (item) { return item.__id; });
          }
        },
        immediate: true
      }
    },
    created: function created () {
      // We register with an error message of 'true' which causes the validation to fail but no message output.
      this.formulateRegisterRule(this.validateGroup.bind(this), [], 'formulateGrouping', true);
    },
    destroyed: function destroyed () {
      this.formulateRemoveRule('formulateGrouping');
    },
    methods: {
      validateGroup: function validateGroup () {
        return Promise.all(this.providers.reduce(function (resolvers, provider) {
          if (provider && typeof provider.hasValidationErrors === 'function') {
            resolvers.push(provider.hasValidationErrors());
          }
          return resolvers
        }, [])).then(function (providersHasErrors) { return !providersHasErrors.some(function (hasErrors) { return !!hasErrors; }); })
      },
      showErrors: function showErrors () {
        this.providers.forEach(function (p) { return p && typeof p.showErrors === 'function' && p.showErrors(); });
      },
      setItem: function setItem (index, groupProxy) {
        var this$1$1 = this;

        // Note: value must have an __id to use this function
        if (Array.isArray(this.context.model) && this.context.model.length >= this.context.minimum && !this.context.model.__init) {
          this.context.model.splice(index, 1, this.setId(groupProxy, index));
        } else {
          this.context.model = this.items.map(function (item, i) { return i === index ? this$1$1.setId(groupProxy, index) : item; });
        }
      },
      removeItem: function removeItem (index) {
        var this$1$1 = this;

        if (Array.isArray(this.context.model) && this.context.model.length > this.context.minimum) {
          // In this context we actually have data
          this.context.model = this.context.model.filter(function (item, i) { return i === index ? false : item; });
          this.context.rootEmit('repeatableRemoved', this.context.model);
        } else if (!Array.isArray(this.context.model) && this.items.length > this.context.minimum) {
          // In this context the fields have never been touched (not "dirty")
          this.context.model = (new Array(this.items.length - 1)).fill('').map(function (_i, idx) { return this$1$1.setId({}, idx); });
          this.context.rootEmit('repeatableRemoved', this.context.model);
        }
        // Otherwise, do nothing, we're at our minimum
      },
      registerProvider: function registerProvider (provider) {
        if (!this.providers.some(function (p) { return p === provider; })) {
          this.providers.push(provider);
        }
      },
      deregisterProvider: function deregisterProvider (provider) {
        this.providers = this.providers.filter(function (p) { return p !== provider; });
      },
      setId: function setId$1 (item, index) {
        return item.__id ? item : setId(item, this.keys[index])
      }
    }
  };

  function render$g(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateRepeatableProvider = resolveComponent("FormulateRepeatableProvider");
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createBlock(_component_FormulateSlot, {
      name: "grouping",
      class: normalizeClass($props.context.classes.grouping),
      context: $props.context,
      "force-wrap": $props.context.repeatable
    }, {
      default: withCtx(function () { return [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.items, function (item, index) {
          return (openBlock(), createBlock(_component_FormulateRepeatableProvider, {
            key: item.__id,
            index: index,
            context: $props.context,
            uuid: item.__id,
            errors: $options.groupErrors[index],
            onRemove: $options.removeItem,
            onInput: function (values) { return $options.setItem(index, values); }
          }, {
            default: withCtx(function () { return [
              renderSlot(_ctx.$slots, "default")
            ]; }),
            _: 2 /* DYNAMIC */
          }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["index", "context", "uuid", "errors", "onRemove", "onInput"]))
        }), 128 /* KEYED_FRAGMENT */))
      ]; }),
      _: 3 /* FORWARDED */
    }, 8 /* PROPS */, ["class", "context", "force-wrap"]))
  }

  script$g.render = render$g;
  script$g.__file = "src/FormulateGrouping.vue";

  var script$f = {
    props: {
      context: {
        type: Object,
        required: true
      }
    }
  };

  var _hoisted_1$b = ["id", "for", "textContent"];

  function render$f(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("label", {
      id: (($props.context.id) + "_label"),
      class: normalizeClass($props.context.classes.label),
      for: $props.context.id,
      textContent: toDisplayString($props.context.label)
    }, null, 10 /* CLASS, PROPS */, _hoisted_1$b))
  }

  script$f.render = render$f;
  script$f.__file = "src/slots/FormulateLabel.vue";

  var script$e = {
    props: {
      context: {
        type: Object,
        required: true
      },
      addMore: {
        type: Function,
        required: true
      }
    }
  };

  function render$e(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateInput = resolveComponent("FormulateInput");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass($props.context.classes.groupAddMore)
    }, [
      createVNode(_component_FormulateInput, {
        type: "button",
        label: $props.context.addLabel,
        "data-minor": "",
        "data-ghost": "",
        onClick: $props.addMore
      }, null, 8 /* PROPS */, ["label", "onClick"])
    ], 2 /* CLASS */))
  }

  script$e.render = render$e;
  script$e.__file = "src/slots/FormulateAddMore.vue";

  /**
   * Default base for input components.
   */
  var FormulateInputMixin = {
    props: {
      context: {
        type: Object,
        required: true
      }
    },
    computed: {
      type: function type () {
        return this.context.type
      },
      attributes: function attributes () {
        return this.context.attributes || {}
      },
      hasValue: function hasValue () {
        return this.context.hasValue
      }
    }
  };

  var script$d = {
    name: 'FormulateInputBox',
    mixins: [FormulateInputMixin],
    computed: {
      usesDecorator: function usesDecorator () {
        return this.$formulate.options.useInputDecorators
      }
    }
  };

  var _hoisted_1$a = ["data-type"];
  var _hoisted_2$6 = ["value"];
  var _hoisted_3$3 = ["value"];

  function render$d(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      createCommentVNode("\n      This explicit break out of types is due to a Vue bug that causes IE11 to\n      not when using v-model + dynamic :type + :value (thanks @Christoph-Wagner)\n      https://github.com/vuejs/vue/issues/8379\n    "),
      (_ctx.type === 'radio')
        ? withDirectives((openBlock(), createElementBlock("input", mergeProps({
            key: 0,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return ((_ctx.context.model) = $event); }),
            type: "radio",
            value: _ctx.context.value
          }, _ctx.attributes, toHandlers(_ctx.$listeners, true), {
            onBlur: _cache[1] || (_cache[1] = function () {
              var ref;

              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
              return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
          }), null, 16 /* FULL_PROPS */, _hoisted_2$6)), [
            [vModelRadio, _ctx.context.model]
          ])
        : withDirectives((openBlock(), createElementBlock("input", mergeProps({
            key: 1,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = function ($event) { return ((_ctx.context.model) = $event); }),
            type: "checkbox",
            value: _ctx.context.value
          }, _ctx.attributes, toHandlers(_ctx.$listeners, true), {
            onBlur: _cache[3] || (_cache[3] = function () {
              var ref;

              var args = [], len = arguments.length;
              while ( len-- ) args[ len ] = arguments[ len ];
              return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
          }), null, 16 /* FULL_PROPS */, _hoisted_3$3)), [
            [vModelCheckbox, _ctx.context.model]
          ]),
      createCommentVNode("\n      Ok, so for reasons that we cannot explain, the <label> here will not\n      update when the attribute.id changes. Possible bug in core? Either way,\n      making this a <component> forces vue to re-render this label when the\n      id changes.\n\n      https://github.com/wearebraid/vue-formulate/issues/75\n    "),
      ($options.usesDecorator)
        ? (openBlock(), createBlock(resolveDynamicComponent("label"), {
            key: 2,
            class: normalizeClass(_ctx.context.classes.decorator),
            for: _ctx.attributes.id
          }, null, 8 /* PROPS */, ["class", "for"]))
        : createCommentVNode("v-if", true),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$a))
  }

  script$d.render = render$d;
  script$d.__file = "src/inputs/FormulateInputBox.vue";

  var script$c = {
    props: {
      visibleErrors: {
        type: Array,
        required: true
      },
      itemClass: {
        type: [String, Array, Object, Boolean],
        default: false
      },
      outerClass: {
        type: [String, Array, Object, Boolean],
        default: false
      },
      role: {
        type: [String],
        default: 'status'
      },
      ariaLive: {
        type: [String, Boolean],
        default: 'polite'
      },
      type: {
        type: String,
        required: true
      }
    }
  };

  var _hoisted_1$9 = ["role", "aria-live", "textContent"];

  function render$c(_ctx, _cache, $props, $setup, $data, $options) {
    return ($props.visibleErrors.length)
      ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass($props.outerClass)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.visibleErrors, function (error) {
            return (openBlock(), createElementBlock("li", {
              key: error,
              class: normalizeClass($props.itemClass),
              role: $props.role,
              "aria-live": $props.ariaLive,
              textContent: toDisplayString(error)
            }, null, 10 /* CLASS, PROPS */, _hoisted_1$9))
          }), 128 /* KEYED_FRAGMENT */))
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  }

  script$c.render = render$c;
  script$c.__file = "src/slots/FormulateErrorList.vue";

  var script$b = {
    name: 'FormulateInputText',
    mixins: [FormulateInputMixin]
  };

  var _hoisted_1$8 = ["data-type"];
  var _hoisted_2$5 = ["type"];

  function render$b(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      withDirectives(createBaseVNode("input", mergeProps({
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return ((_ctx.context.model) = $event); }),
        type: _ctx.type
      }, _ctx.attributes, {
        onBlur: _cache[1] || (_cache[1] = function () {
          var ref;

          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
      }, toHandlers(_ctx.$listeners, true)), null, 16 /* FULL_PROPS */, _hoisted_2$5), [
        [vModelDynamic, _ctx.context.model]
      ]),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$8))
  }

  script$b.render = render$b;
  script$b.__file = "src/inputs/FormulateInputText.vue";

  var script$a = {
    name: 'FormulateFiles',
    props: {
      files: {
        type: FileUpload,
        required: true
      },
      imagePreview: {
        type: Boolean,
        default: false
      },
      context: {
        type: Object,
        required: true
      }
    },
    computed: {
      fileUploads: function fileUploads () {
        return this.files.files || []
      },
      isMultiple: function isMultiple () {
        return has$1(this.context.attributes, 'multiple')
      }
    },
    watch: {
      files: function files () {
        if (this.imagePreview) {
          this.files.loadPreviews();
        }
      }
    },
    mounted: function mounted () {
      if (this.imagePreview) {
        this.files.loadPreviews();
      }
    },
    methods: {
      appendFiles: function appendFiles () {
        var input = this.$refs.addFiles;
        if (input.files.length) {
          this.files.mergeFileList(input);
        }
      }
    }
  };

  var _hoisted_1$7 = ["data-has-error", "data-has-preview"];
  var _hoisted_2$4 = ["textContent"];

  function render$a(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return ($options.fileUploads.length)
      ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass($props.context.classes.files)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.fileUploads, function (file) {
            return (openBlock(), createElementBlock("li", {
              key: file.uuid,
              "data-has-error": !!file.error,
              "data-has-preview": !!($props.imagePreview && file.previewData)
            }, [
              createVNode(_component_FormulateSlot, {
                name: "file",
                context: $props.context,
                file: file,
                "image-preview": $props.imagePreview
              }, {
                default: withCtx(function () { return [
                  (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.file), {
                    context: $props.context,
                    file: file,
                    "image-preview": $props.imagePreview
                  }, null, 8 /* PROPS */, ["context", "file", "image-preview"]))
                ]; }),
                _: 2 /* DYNAMIC */
              }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["context", "file", "image-preview"]),
              (file.error)
                ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass($props.context.classes.fileUploadError),
                    textContent: toDisplayString(file.error)
                  }, null, 10 /* CLASS, PROPS */, _hoisted_2$4))
                : createCommentVNode("v-if", true)
            ], 8 /* PROPS */, _hoisted_1$7))
          }), 128 /* KEYED_FRAGMENT */)),
          ($options.isMultiple && $props.context.addLabel)
            ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass($props.context.classes.fileAdd),
                role: "button"
              }, [
                createTextVNode(toDisplayString($props.context.addLabel) + " ", 1 /* TEXT */),
                createBaseVNode("input", {
                  ref: "addFiles",
                  type: "file",
                  multiple: "",
                  class: normalizeClass($props.context.classes.fileAddInput),
                  onChange: _cache[0] || (_cache[0] = function () {
                    var args = [], len = arguments.length;
                    while ( len-- ) args[ len ] = arguments[ len ];

                    return ($options.appendFiles && $options.appendFiles.apply($options, args));
    })
                }, null, 34 /* CLASS, NEED_HYDRATION */)
              ], 2 /* CLASS */))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  }

  script$a.render = render$a;
  script$a.__file = "src/FormulateFiles.vue";

  var script$9 = {
    name: 'FormulateInputFile',
    components: {
      FormulateFiles: script$a
    },
    mixins: [FormulateInputMixin],
    data: function data () {
      return {
        isOver: false
      }
    },
    computed: {
      hasFiles: function hasFiles () {
        return !!(this.context.model instanceof FileUpload && this.context.model.files.length)
      }
    },
    created: function created () {
      if (Array.isArray(this.context.model)) {
        if (typeof this.context.model[0][this.$formulate.getFileUrlKey()] === 'string') {
          this.context.model = this.$formulate.createUpload({
            files: this.context.model
          }, this.context);
        }
      }
    },
    mounted: function mounted () {
      // Add a listener to the window to prevent drag/drops that miss the dropzone
      // from opening the file and navigating the user away from the page.
      if (window && this.context.preventWindowDrops) {
        window.addEventListener('dragover', this.preventDefault);
        window.addEventListener('drop', this.preventDefault);
      }
    },
    destroyed: function destroyed () {
      if (window && this.context.preventWindowDrops) {
        window.removeEventListener('dragover', this.preventDefault);
        window.removeEventListener('drop', this.preventDefault);
      }
    },
    methods: {
      preventDefault: function preventDefault (e) {
        if (e.target.tagName !== 'INPUT' && e.target.getAttribute('type') !== 'file') {
          e = e || event;
          e.preventDefault();
        }
      },
      handleFile: function handleFile () {
        var this$1$1 = this;

        this.isOver = false;
        var input = this.$refs.file;
        if (input.files.length) {
          this.context.model = this.$formulate.createUpload(input, this.context);
          // nextTick required for attemptImmediateUpload to pass instanceof reliably
          this.$nextTick(function () { return this$1$1.attemptImmediateUpload(); });
        }
      },
      attemptImmediateUpload: function attemptImmediateUpload () {
        var this$1$1 = this;

        if (this.context.uploadBehavior === 'live' &&
          this.context.model instanceof FileUpload) {
          this.context.hasValidationErrors().then(function (errors) {
            if (!errors) {
              this$1$1.context.model.upload();
            }
          });
        }
      },
      handleDragOver: function handleDragOver (e) {
        e.preventDefault();
        this.isOver = true;
      },
      handleDragLeave: function handleDragLeave (e) {
        e.preventDefault();
        this.isOver = false;
      }
    }
  };

  var _hoisted_1$6 = ["data-type", "data-has-files"];
  var _hoisted_2$3 = ["data-has-files"];
  var _hoisted_3$2 = ["data-is-drag-hover"];

  function render$9(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");
    var _component_FormulateFiles = resolveComponent("FormulateFiles");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type,
      "data-has-files": $options.hasFiles
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.context.classes.uploadArea),
        "data-has-files": $options.hasFiles
      }, [
        createBaseVNode("input", mergeProps({
          ref: "file",
          "data-is-drag-hover": $data.isOver,
          type: "file"
        }, _ctx.attributes, toHandlers(_ctx.$listeners, true), {
          onBlur: _cache[0] || (_cache[0] = function () {
            var ref;

            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
            return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    }),
          onChange: _cache[1] || (_cache[1] = function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return ($options.handleFile && $options.handleFile.apply($options, args));
    }),
          onDragover: _cache[2] || (_cache[2] = function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return ($options.handleDragOver && $options.handleDragOver.apply($options, args));
    }),
          onDragleave: _cache[3] || (_cache[3] = function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return ($options.handleDragLeave && $options.handleDragLeave.apply($options, args));
    })
        }), null, 16 /* FULL_PROPS */, _hoisted_3$2),
        createVNode(_component_FormulateSlot, {
          name: "uploadAreaMask",
          context: _ctx.context,
          "has-files": $options.hasFiles
        }, {
          default: withCtx(function () { return [
            withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.uploadAreaMask), {
              "has-files": _ctx.context.slotComponents.uploadAreaMask === 'div' ? false : $options.hasFiles,
              "data-has-files": _ctx.context.slotComponents.uploadAreaMask === 'div' ? $options.hasFiles : false,
              class: normalizeClass(_ctx.context.classes.uploadAreaMask)
            }, null, 8 /* PROPS */, ["has-files", "data-has-files", "class"])), [
              [vShow, !$options.hasFiles]
            ])
          ]; }),
          _: 1 /* STABLE */
        }, 8 /* PROPS */, ["context", "has-files"]),
        ($options.hasFiles)
          ? (openBlock(), createBlock(_component_FormulateFiles, {
              key: 0,
              files: _ctx.context.model,
              "image-preview": _ctx.context.type === 'image' && _ctx.context.imageBehavior === 'preview',
              context: _ctx.context
            }, null, 8 /* PROPS */, ["files", "image-preview", "context"]))
          : createCommentVNode("v-if", true)
      ], 10 /* CLASS, PROPS */, _hoisted_2$3),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$6))
  }

  script$9.render = render$9;
  script$9.__file = "src/inputs/FormulateInputFile.vue";

  var script$8 = {
    props: {
      context: {
        type: Object,
        required: true
      },
      removeItem: {
        type: Function,
        required: true
      },
      index: {
        type: Number,
        required: true
      }
    }
  };

  function render$8(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass($props.context.classes.groupRepeatable)
    }, [
      ($props.context.removePosition === 'after')
        ? renderSlot(_ctx.$slots, "default", { key: 0 })
        : createCommentVNode("v-if", true),
      createVNode(_component_FormulateSlot, {
        name: "remove",
        context: $props.context,
        index: $props.index,
        "remove-item": $props.removeItem
      }, {
        default: withCtx(function () { return [
          (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.remove), mergeProps({
            context: $props.context,
            index: $props.index,
            "remove-item": $props.removeItem
          }, $props.context.slotProps.remove), null, 16 /* FULL_PROPS */, ["context", "index", "remove-item"]))
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context", "index", "remove-item"]),
      ($props.context.removePosition === 'before')
        ? renderSlot(_ctx.$slots, "default", { key: 1 })
        : createCommentVNode("v-if", true)
    ], 2 /* CLASS */))
  }

  script$8.render = render$8;
  script$8.__file = "src/slots/FormulateRepeatable.vue";

  function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  var script$7 = {
    name: 'FormulateInputGroup',
    props: {
      context: {
        type: Object,
        required: true
      }
    },
    computed: {
      options: function options () {
        return this.context.options || []
      },
      subType: function subType () {
        return (this.context.type === 'group') ? 'grouping' : 'inputs'
      },
      optionsWithContext: function optionsWithContext () {
        var this$1$1 = this;

        var ref = this.context;
        var ref_attributes = ref.attributes;
        ref_attributes.id;
        var rest = objectWithoutProperties( ref_attributes, ["id"] );
        var groupApplicableAttributes = rest;
        ref.blurHandler;
        ref.classification;
        ref.component;
        ref.getValidationErrors;
        ref.hasLabel;
        ref.hasValidationErrors;
        ref.isSubField;
        ref.isValid;
        ref.labelPosition;
        ref.options;
        ref.performValidation;
        ref.setErrors;
        ref.slotComponents;
        ref.slotProps;
        ref.validationErrors;
        ref.visibleValidationErrors;
        ref.classes;
        ref.showValidationErrors;
        ref.rootEmit;
        ref.help;
        ref.pseudoProps;
        ref.rules;
        ref.model;
        var rest$1 = objectWithoutProperties( ref, ["attributes", "blurHandler", "classification", "component", "getValidationErrors", "hasLabel", "hasValidationErrors", "isSubField", "isValid", "labelPosition", "options", "performValidation", "setErrors", "slotComponents", "slotProps", "validationErrors", "visibleValidationErrors", "classes", "showValidationErrors", "rootEmit", "help", "pseudoProps", "rules", "model"] );
        var context = rest$1;
        return this.options.map(function (option) { return this$1$1.groupItemContext(
          context,
          option,
          groupApplicableAttributes
        ); })
      },
      totalItems: function totalItems () {
        return Array.isArray(this.context.model) && this.context.model.length > this.context.minimum
          ? this.context.model.length
          : this.context.minimum || 1
      },
      canAddMore: function canAddMore () {
        return (this.context.repeatable && this.totalItems < this.context.limit)
      },
      labelledBy: function labelledBy () {
        return this.context.label && ((this.context.id) + "_label")
      }
    },
    methods: {
      addItem: function addItem () {
        if (Array.isArray(this.context.model)) {
          var minDiff = (this.context.minimum - this.context.model.length) + 1;
          var toAdd = Math.max(minDiff, 1);
          for (var i = 0; i < toAdd; i++) {
            this.context.model.push(setId({}));
          }
        } else {
          this.context.model = (new Array(this.totalItems + 1)).fill('').map(function () { return setId({}); });
        }
        this.context.rootEmit('repeatableAdded', this.context.model);
      },
      groupItemContext: function groupItemContext (context, option, groupAttributes) {
        var optionAttributes = { isGrouped: true };
        var ctx = Object.assign({}, context, option, groupAttributes, optionAttributes, !context.hasGivenName ? {
          name: true
        } : {});
        return ctx
      }
    }
  };

  var _hoisted_1$5 = ["data-is-repeatable", "aria-labelledby"];

  function render$7(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");
    var _component_FormulateInput = resolveComponent("FormulateInput");
    var _component_FormulateGrouping = resolveComponent("FormulateGrouping");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass($props.context.classes.element),
      "data-is-repeatable": $props.context.repeatable,
      role: "group",
      "aria-labelledby": $options.labelledBy
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: $props.context
      }, {
        default: withCtx(function () { return [
          ($props.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.prefix), {
                key: 0,
                context: $props.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      ($options.subType !== 'grouping')
        ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.optionsWithContext, function (optionContext) {
            return (openBlock(), createBlock(_component_FormulateInput, mergeProps({
              key: optionContext.id,
              modelValue: $props.context.model,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return (($props.context.model) = $event); }),
              ref_for: true
            }, optionContext, {
              "disable-errors": true,
              "prevent-deregister": true,
              class: "formulate-input-group-item",
              onBlur: $props.context.blurHandler
            }), null, 16 /* FULL_PROPS */, ["modelValue", "onBlur"]))
          }), 128 /* KEYED_FRAGMENT */))
        : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createVNode(_component_FormulateGrouping, { context: $props.context }, {
              default: withCtx(function () { return [
                renderSlot(_ctx.$slots, "default")
              ]; }),
              _: 3 /* FORWARDED */
            }, 8 /* PROPS */, ["context"]),
            ($options.canAddMore)
              ? (openBlock(), createBlock(_component_FormulateSlot, {
                  key: 0,
                  name: "addmore",
                  context: $props.context,
                  "add-more": $options.addItem
                }, {
                  default: withCtx(function () { return [
                    (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.addMore), mergeProps({
                      context: $props.context,
                      "add-more": $options.addItem
                    }, $props.context.slotProps.addMore, { onAdd: $options.addItem }), null, 16 /* FULL_PROPS */, ["context", "add-more", "onAdd"]))
                  ]; }),
                  _: 1 /* STABLE */
                }, 8 /* PROPS */, ["context", "add-more"]))
              : createCommentVNode("v-if", true)
          ], 64 /* STABLE_FRAGMENT */)),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: $props.context
      }, {
        default: withCtx(function () { return [
          ($props.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.suffix), {
                key: 0,
                context: $props.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$5))
  }

  script$7.render = render$7;
  script$7.__file = "src/inputs/FormulateInputGroup.vue";

  var script$6 = {
    name: 'FormulateInputButton',
    mixins: [FormulateInputMixin]
  };

  var _hoisted_1$4 = ["data-type"];
  var _hoisted_2$2 = ["type"];

  function render$6(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      createBaseVNode("button", mergeProps({ type: _ctx.type }, _ctx.attributes, toHandlers(_ctx.$listeners, true)), [
        renderSlot(_ctx.$slots, "default", { context: _ctx.context }, function () { return [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.buttonContent), { context: _ctx.context }, null, 8 /* PROPS */, ["context"]))
        ]; })
      ], 16 /* FULL_PROPS */, _hoisted_2$2),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$4))
  }

  script$6.render = render$6;
  script$6.__file = "src/inputs/FormulateInputButton.vue";

  var script$5 = {
    name: 'FormulateInputSelect',
    mixins: [FormulateInputMixin],
    computed: {
      options: function options () {
        return this.context.options || {}
      },
      optionGroups: function optionGroups () {
        return this.context.optionGroups || false
      },
      placeholderSelected: function placeholderSelected () {
        return !!(!this.hasValue && this.context.attributes && this.context.attributes.placeholder)
      }
    }
  };

  var _hoisted_1$3 = ["data-type", "data-multiple"];
  var _hoisted_2$1 = ["data-placeholder-selected"];
  var _hoisted_3$1 = ["selected"];
  var _hoisted_4 = ["value", "disabled", "textContent"];
  var _hoisted_5 = ["label"];
  var _hoisted_6 = ["value", "disabled", "textContent"];

  function render$5(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type,
      "data-multiple": _ctx.attributes && _ctx.attributes.multiple !== undefined
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      withDirectives(createBaseVNode("select", mergeProps({
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return ((_ctx.context.model) = $event); })
      }, _ctx.attributes, { "data-placeholder-selected": $options.placeholderSelected }, toHandlers(_ctx.$listeners, true), {
        onBlur: _cache[1] || (_cache[1] = function () {
          var ref;

          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
      }), [
        (_ctx.context.placeholder)
          ? (openBlock(), createElementBlock("option", {
              key: 0,
              value: "",
              hidden: "hidden",
              disabled: "",
              selected: !_ctx.hasValue
            }, toDisplayString(_ctx.context.placeholder), 9 /* TEXT, PROPS */, _hoisted_3$1))
          : createCommentVNode("v-if", true),
        (!$options.optionGroups)
          ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($options.options, function (option) {
              return (openBlock(), createElementBlock("option", mergeProps({
                key: option.id,
                value: option.value,
                disabled: !!option.disabled,
                ref_for: true
              }, option.attributes || option.attrs || {}, {
                textContent: toDisplayString(option.label)
              }), null, 16 /* FULL_PROPS */, _hoisted_4))
            }), 128 /* KEYED_FRAGMENT */))
          : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList($options.optionGroups, function (subOptions, label) {
              return (openBlock(), createElementBlock("optgroup", {
                key: label,
                label: label
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(subOptions, function (option) {
                  return (openBlock(), createElementBlock("option", mergeProps({
                    key: option.id,
                    value: option.value,
                    disabled: !!option.disabled,
                    ref_for: true
                  }, option.attributes || option.attrs || {}, {
                    textContent: toDisplayString(option.label)
                  }), null, 16 /* FULL_PROPS */, _hoisted_6))
                }), 128 /* KEYED_FRAGMENT */))
              ], 8 /* PROPS */, _hoisted_5))
            }), 128 /* KEYED_FRAGMENT */))
      ], 16 /* FULL_PROPS */, _hoisted_2$1), [
        [vModelSelect, _ctx.context.model]
      ]),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$3))
  }

  script$5.render = render$5;
  script$5.__file = "src/inputs/FormulateInputSelect.vue";

  var script$4 = {
    name: 'FormulateInputSlider',
    mixins: [FormulateInputMixin]
  };

  var _hoisted_1$2 = ["data-type"];
  var _hoisted_2 = ["type"];
  var _hoisted_3 = ["textContent"];

  function render$4(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": _ctx.context.type
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      withDirectives(createBaseVNode("input", mergeProps({
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return ((_ctx.context.model) = $event); }),
        type: _ctx.type
      }, _ctx.attributes, toHandlers(_ctx.$listeners, true), {
        onBlur: _cache[1] || (_cache[1] = function () {
          var ref;

          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
      }), null, 16 /* FULL_PROPS */, _hoisted_2), [
        [vModelDynamic, _ctx.context.model]
      ]),
      (_ctx.context.showValue)
        ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.context.classes.rangeValue),
            textContent: toDisplayString(_ctx.context.model)
          }, null, 10 /* CLASS, PROPS */, _hoisted_3))
        : createCommentVNode("v-if", true),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 10 /* CLASS, PROPS */, _hoisted_1$2))
  }

  script$4.render = render$4;
  script$4.__file = "src/inputs/FormulateInputSlider.vue";

  var script$3 = {
    props: {
      context: {
        type: Object,
        required: true
      }
    }
  };

  var _hoisted_1$1 = ["textContent"];

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    return (openBlock(), createElementBlock("span", {
      class: normalizeClass(("formulate-input-element--" + ($props.context.type) + "--label")),
      textContent: toDisplayString($props.context.value || $props.context.label || $props.context.name || 'Submit')
    }, null, 10 /* CLASS, PROPS */, _hoisted_1$1))
  }

  script$3.render = render$3;
  script$3.__file = "src/slots/FormulateButtonContent.vue";

  var script$2 = {
    name: 'FormulateInputTextArea',
    mixins: [FormulateInputMixin]
  };

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createElementBlock("div", {
      class: normalizeClass(_ctx.context.classes.element),
      "data-type": "textarea"
    }, [
      createVNode(_component_FormulateSlot, {
        name: "prefix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.prefix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.prefix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"]),
      withDirectives(createBaseVNode("textarea", mergeProps({
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) { return ((_ctx.context.model) = $event); })
      }, _ctx.attributes, toHandlers(_ctx.$listeners, true), {
        onBlur: _cache[1] || (_cache[1] = function () {
          var ref;

          var args = [], len = arguments.length;
          while ( len-- ) args[ len ] = arguments[ len ];
          return (_ctx.context.blurHandler && (ref = _ctx.context).blurHandler.apply(ref, args));
    })
      }), null, 16 /* FULL_PROPS */), [
        [vModelText, _ctx.context.model]
      ]),
      createVNode(_component_FormulateSlot, {
        name: "suffix",
        context: _ctx.context
      }, {
        default: withCtx(function () { return [
          (_ctx.context.slotComponents.suffix)
            ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.context.slotComponents.suffix), {
                key: 0,
                context: _ctx.context
              }, null, 8 /* PROPS */, ["context"]))
            : createCommentVNode("v-if", true)
        ]; }),
        _: 1 /* STABLE */
      }, 8 /* PROPS */, ["context"])
    ], 2 /* CLASS */))
  }

  script$2.render = render$2;
  script$2.__file = "src/inputs/FormulateInputTextArea.vue";

  var script$1 = {
    provide: function provide () {
      var this$1$1 = this;

      return Object.assign({}, useRegistryProviders(this, ['getFormValues']),
        {formulateSetter: function (field, value) { return this$1$1.setGroupValue(field, value); }})
    },
    inject: {
      registerProvider: 'registerProvider',
      deregisterProvider: 'deregisterProvider'
    },
    props: {
      index: {
        type: Number,
        required: true
      },
      context: {
        type: Object,
        required: true
      },
      uuid: {
        type: String,
        required: true
      },
      errors: {
        type: Object,
        required: true
      }
    },
    data: function data () {
      return Object.assign({}, useRegistry(this),
        {isGrouping: true})
    },
    computed: Object.assign({}, useRegistryComputed(),
      {mergedFieldErrors: function mergedFieldErrors () {
        return this.errors
      }}),
    watch: Object.assign({}, useRegistryWatchers(),
      {'context.model': {
        handler: function handler (values) {
          if (!equals(values[this.index], this.proxy, true)) {
            this.setValues(values[this.index]);
          }
        },
        deep: true
      }}),
    created: function created () {
      this.applyInitialValues();
      this.registerProvider(this);
    },
    beforeDestroy: function beforeDestroy () {
      this.preventCleanup = true;
      this.deregisterProvider(this);
    },
    methods: Object.assign({}, useRegistryMethods(),
      {setGroupValue: function setGroupValue (field, value) {
        if (!equals(this.proxy[field], value, true)) {
          this.setFieldValue(field, value);
        }
      },
      removeItem: function removeItem () {
        this.$emit('remove', this.index);
      }})
  };

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_FormulateSlot = resolveComponent("FormulateSlot");

    return (openBlock(), createBlock(_component_FormulateSlot, {
      name: "repeatable",
      context: $props.context,
      index: $props.index,
      "remove-item": $options.removeItem
    }, {
      default: withCtx(function () { return [
        (openBlock(), createBlock(resolveDynamicComponent($props.context.slotComponents.repeatable), mergeProps({
          context: $props.context,
          index: $props.index,
          "remove-item": $options.removeItem
        }, $props.context.slotProps.repeatable), {
          default: withCtx(function () { return [
            createVNode(_component_FormulateSlot, {
              context: $props.context,
              index: $props.index,
              name: "default"
            }, null, 8 /* PROPS */, ["context", "index"])
          ]; }),
          _: 1 /* STABLE */
        }, 16 /* FULL_PROPS */, ["context", "index", "remove-item"]))
      ]; }),
      _: 1 /* STABLE */
    }, 8 /* PROPS */, ["context", "index", "remove-item"]))
  }

  script$1.render = render$1;
  script$1.__file = "src/FormulateRepeatableProvider.vue";

  var script = {
    props: {
      index: {
        type: Number,
        default: null
      },
      context: {
        type: Object,
        required: true
      },
      removeItem: {
        type: Function,
        required: true
      }
    }
  };

  var _hoisted_1 = ["data-disabled", "textContent"];

  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return ($props.context.repeatable)
      ? (openBlock(), createElementBlock("a", {
          key: 0,
          class: normalizeClass($props.context.classes.groupRepeatableRemove),
          "data-disabled": $props.context.model.length <= $props.context.minimum,
          role: "button",
          onClick: _cache[0] || (_cache[0] = withModifiers(function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return ($props.removeItem && $props.removeItem.apply($props, args));
    }, ["prevent"])),
          onKeypress: _cache[1] || (_cache[1] = withKeys(function () {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];

            return ($props.removeItem && $props.removeItem.apply($props, args));
    }, ["enter"])),
          textContent: toDisplayString($props.context.removeLabel)
        }, null, 42 /* CLASS, PROPS, NEED_HYDRATION */, _hoisted_1))
      : createCommentVNode("v-if", true)
  }

  script.render = render;
  script.__file = "src/slots/FormulateRepeatableRemove.vue";

  /**
   * The base formulate library.
   */
  var Formulate = function Formulate () {
    this.options = {};
    this.defaults = {
      components: {
        FormulateSlot: FormulateSlot,
        FormulateForm: script$l,
        FormulateFile: script$h,
        FormulateHelp: script$i,
        FormulateLabel: script$f,
        FormulateInput: script$k,
        FormulateErrors: script$j,
        FormulateSchema: FormulateSchema,
        FormulateAddMore: script$e,
        FormulateGrouping: script$g,
        FormulateInputBox: script$d,
        FormulateInputText: script$b,
        FormulateInputFile: script$9,
        FormulateErrorList: script$c,
        FormulateRepeatable: script$8,
        FormulateInputGroup: script$7,
        FormulateInputButton: script$6,
        FormulateInputSelect: script$5,
        FormulateInputSlider: script$4,
        FormulateButtonContent: script$3,
        FormulateInputTextArea: script$2,
        FormulateRepeatableRemove: script,
        FormulateRepeatableProvider: script$1
      },
      slotComponents: {
        addMore: 'FormulateAddMore',
        buttonContent: 'FormulateButtonContent',
        errorList: 'FormulateErrorList',
        errors: 'FormulateErrors',
        file: 'FormulateFile',
        help: 'FormulateHelp',
        label: 'FormulateLabel',
        prefix: false,
        remove: 'FormulateRepeatableRemove',
        repeatable: 'FormulateRepeatable',
        suffix: false,
        uploadAreaMask: 'div'
      },
      slotProps: {},
      library: library,
      rules: rules,
      mimes: mimes,
      locale: false,
      uploader: fauxUploader,
      uploadUrl: false,
      fileUrlKey: 'url',
      uploadJustCompleteDuration: 1000,
      errorHandler: function (err) { return err; },
      plugins: [ vueFormulateI18n.en ],
      locales: {},
      failedValidation: function () { return false; },
      idPrefix: 'formulate-',
      baseClasses: function (b) { return b; },
      coreClasses: coreClasses,
      classes: {},
      useInputDecorators: true,
      validationNameStrategy: false
    };
    this.registry = new Map();
    this.idRegistry = {};
  };

  /**
   * Install vue formulate, and register it’s components.
   */
  Formulate.prototype.install = function install (Vue, options) {
      var this$1$1 = this;

    Vue.prototype.$formulate = this;
    this.options = this.defaults;
    var plugins = this.defaults.plugins;
    if (options && Array.isArray(options.plugins) && options.plugins.length) {
      plugins = plugins.concat(options.plugins);
    }
    plugins.forEach(function (plugin) { return (typeof plugin === 'function') ? plugin(this$1$1) : null; });
    this.extend(options || {});
    for (var componentName in this.options.components) {
      Vue.component(componentName, this.options.components[componentName]);
    }
  };

  /**
   * Produce a deterministically generated id based on the sequence by which it
   * was requested. This should be *theoretically* the same SSR as client side.
   * However, SSR and deterministic ids can be very challenging, so this
   * implementation is open to community review.
   */
  Formulate.prototype.nextId = function nextId (vm) {
    var path = vm.$route && vm.$route.path ? vm.$route.path : false;
    var pathPrefix = path ? vm.$route.path.replace(/[/\\.\s]/g, '-') : 'global';
    if (!Object.prototype.hasOwnProperty.call(this.idRegistry, pathPrefix)) {
      this.idRegistry[pathPrefix] = 0;
    }
    return ("" + (this.options.idPrefix) + pathPrefix + "-" + (++this.idRegistry[pathPrefix]))
  };

  /**
   * Given a set of options, apply them to the pre-existing options.
   * @param {Object} extendWith
   */
  Formulate.prototype.extend = function extend (extendWith) {
    if (typeof extendWith === 'object') {
      this.options = this.merge(this.options, extendWith);
      return this
    }
    throw new Error(("Formulate.extend expects an object, was " + (typeof extendWith)))
  };

  /**
   * Create a new object by copying properties of base and mergeWith.
   * Note: arrays don't overwrite - they push
   *
   * @param {Object} base
   * @param {Object} mergeWith
   * @param {boolean} concatArrays
   */
  Formulate.prototype.merge = function merge (base, mergeWith, concatArrays) {
      if ( concatArrays === void 0 ) concatArrays = true;

    var merged = {};
    for (var key in base) {
      if (mergeWith.hasOwnProperty(key)) {
        if (isPlainObject$1(mergeWith[key]) && isPlainObject$1(base[key])) {
          merged[key] = this.merge(base[key], mergeWith[key], concatArrays);
        } else if (concatArrays && Array.isArray(base[key]) && Array.isArray(mergeWith[key])) {
          merged[key] = base[key].concat(mergeWith[key]);
        } else {
          merged[key] = mergeWith[key];
        }
      } else {
        merged[key] = base[key];
      }
    }
    for (var prop in mergeWith) {
      if (!merged.hasOwnProperty(prop)) {
        merged[prop] = mergeWith[prop];
      }
    }
    return merged
  };

  /**
   * Determine what "class" of input this element is given the "type".
   * @param {string} type
   */
  Formulate.prototype.classify = function classify (type) {
    if (this.options.library.hasOwnProperty(type)) {
      return this.options.library[type].classification
    }
    return 'unknown'
  };

  /**
   * Generate all classes for a particular context.
   * @param {Object} context
   */
  Formulate.prototype.classes = function classes (classContext) {
      var this$1$1 = this;

    // Step 1: We get the global classes for all keys.
    var coreClasses = this.options.coreClasses(classContext);
    // Step 2: We extend those classes with a user defined baseClasses.
    var baseClasses = this.options.baseClasses(coreClasses, classContext);
    return Object.keys(baseClasses).reduce(function (classMap, key) {
        var obj;

      // Step 3: For each key, apply any global overrides for that key.
      var classesForKey = applyClasses(baseClasses[key], this$1$1.options.classes[key], classContext);
      // Step 4: Apply any prop-level overrides for that key.
      classesForKey = applyClasses(classesForKey, classContext[(key + "Class")], classContext);
      // Step 5: Add state based classes from props.
      classesForKey = applyStates(key, classesForKey, this$1$1.options.classes, classContext);
      // Now we have our final classes, assign to the given key.
      return Object.assign(classMap, ( obj = {}, obj[key] = classesForKey, obj ))
    }, {})
  };

  /**
   * Given a particular type, report any "additional" props to pass to the
   * various slots.
   * @param {string} type
   * @return {array}
   */
  Formulate.prototype.typeProps = function typeProps (type) {
    var extract = function (obj) { return Object.keys(obj).reduce(function (props, slot) {
      return Array.isArray(obj[slot]) ? props.concat(obj[slot]) : props
    }, []); };
    var props = extract(this.options.slotProps);
    return this.options.library[type]
      ? props.concat(extract(this.options.library[type].slotProps || {}))
      : props
  };

  /**
   * Given a type and a slot, get the relevant slot props object.
   * @param {string} type
   * @param {string} slot
   * @return {object}
   */
  Formulate.prototype.slotProps = function slotProps (type, slot, typeProps) {
    var props = Array.isArray(this.options.slotProps[slot]) ? this.options.slotProps[slot] : [];
    var def = this.options.library[type];
    if (def && def.slotProps && Array.isArray(def.slotProps[slot])) {
      props = props.concat(def.slotProps[slot]);
    }
    return props.reduce(function (props, prop) {
        var obj;

        return Object.assign(props, ( obj = {}, obj[prop] = typeProps[prop], obj ));
      }, {})
  };

  /**
   * Determine what type of component to render given the "type".
   * @param {string} type
   */
  Formulate.prototype.component = function component (type) {
    if (this.options.library.hasOwnProperty(type)) {
      return this.options.library[type].component
    }
    return false
  };

  /**
   * What component should be rendered for the given slot location and type.
   * @param {string} type the type of component
   * @param {string} slot the name of the slot
   */
  Formulate.prototype.slotComponent = function slotComponent (type, slot) {
    var def = this.options.library[type];
    if (def && def.slotComponents && def.slotComponents[slot]) {
      return def.slotComponents[slot]
    }
    return this.options.slotComponents[slot]
  };

  /**
   * Get validation rules by merging any passed in with global rules.
   * @return {object} object of validation functions
   */
  Formulate.prototype.rules = function rules (rules) {
      if ( rules === void 0 ) rules = {};

    return Object.assign({}, this.options.rules, rules)
  };

  /**
   * Attempt to get the vue-i18n configured locale.
   */
  Formulate.prototype.i18n = function i18n (vm) {
    if (vm.$i18n) {
      switch (typeof vm.$i18n.locale) {
        case 'string':
          return vm.$i18n.locale
        case 'function':
          return vm.$i18n.locale()
      }
    }
    return false
  };

  /**
   * Select the proper locale to use.
   */
  Formulate.prototype.getLocale = function getLocale (vm) {
      var this$1$1 = this;

    if (!this.selectedLocale) {
      this.selectedLocale = [
        this.options.locale,
        this.i18n(vm),
        'en'
      ].reduce(function (selection, locale) {
        if (selection) {
          return selection
        }
        if (locale) {
          var option = parseLocale(locale)
            .find(function (locale) { return has$1(this$1$1.options.locales, locale); });
          if (option) {
            selection = option;
          }
        }
        return selection
      }, false);
    }
    return this.selectedLocale
  };

  /**
   * Change the locale to a pre-registered one.
   * @param {string} localeTag
   */
  Formulate.prototype.setLocale = function setLocale (locale) {
    if (has$1(this.options.locales, locale)) {
      this.options.locale = locale;
      this.selectedLocale = locale;
      // Trigger validation on all forms to swap languages
      this.registry.forEach(function (form, name) {
        form.hasValidationErrors();
      });
    }
  };

  /**
   * Get the validation message for a particular error.
   */
  Formulate.prototype.validationMessage = function validationMessage (rule, validationContext, vm) {
    var generators = this.options.locales[this.getLocale(vm)];
    if (generators.hasOwnProperty(rule)) {
      return generators[rule](validationContext)
    }
    if (generators.hasOwnProperty('default')) {
      return generators.default(validationContext)
    }
    return 'Invalid field value'
  };

  /**
   * Given an instance of a FormulateForm register it.
   * @param {vm} form
   */
  Formulate.prototype.register = function register (form) {
    if (form.$options.name === 'FormulateForm' && form.name) {
      this.registry.set(form.name, form);
    }
  };

  /**
   * Given an instance of a form, remove it from the registry.
   * @param {vm} form
   */
  Formulate.prototype.deregister = function deregister (form) {
    if (
      form.$options.name === 'FormulateForm' &&
      form.name &&
      this.registry.has(form.name)
    ) {
      this.registry.delete(form.name);
    }
  };

  /**
   * Given an array, this function will attempt to make sense of the given error
   * and hydrate a form with the resulting errors.
   *
   * @param {error} err
   * @param {string} formName
   * @param {error}
   */
  Formulate.prototype.handle = function handle (err, formName, skip) {
      if ( skip === void 0 ) skip = false;

    var e = skip ? err : this.options.errorHandler(err, formName);
    if (formName && this.registry.has(formName)) {
      this.registry.get(formName).applyErrors({
        formErrors: arrayify(e.formErrors),
        inputErrors: e.inputErrors || {}
      });
    }
    return e
  };

  /**
   * Reset a form.
   * @param {string} formName
   * @param {object} initialValue
   */
  Formulate.prototype.reset = function reset (formName, initialValue) {
      if ( initialValue === void 0 ) initialValue = {};

    this.resetValidation(formName);
    this.setValues(formName, initialValue);
  };

  /**
   * Submit a named form.
   * @param {string} formName
   */
  Formulate.prototype.submit = function submit (formName) {
    var form = this.registry.get(formName);
    form.formSubmitted();
  };

  /**
   * Reset the form's validation messages.
   * @param {string} formName
   */
  Formulate.prototype.resetValidation = function resetValidation (formName) {
    var form = this.registry.get(formName);
    form.hideErrors(formName);
    form.namedErrors = [];
    form.namedFieldErrors = {};
  };

  /**
   * Set the form values.
   * @param {string} formName
   * @param {object} values
   */
  Formulate.prototype.setValues = function setValues (formName, values) {
    if (values && !Array.isArray(values) && typeof values === 'object') {
      var form = this.registry.get(formName);
      form.setValues(Object.assign({}, values));
    }
  };

  /**
   * Get the file uploader.
   */
  Formulate.prototype.getUploader = function getUploader () {
    return this.options.uploader || false
  };

  /**
   * Get the global upload url.
   */
  Formulate.prototype.getUploadUrl = function getUploadUrl () {
    return this.options.uploadUrl || false
  };

  /**
   * When re-hydrating a file uploader with an array, get the sub-object key to
   * access the url of the file. Usually this is just "url".
   */
  Formulate.prototype.getFileUrlKey = function getFileUrlKey () {
    return this.options.fileUrlKey || 'url'
  };

  /**
   * Create a new instance of an upload.
   */
  Formulate.prototype.createUpload = function createUpload (fileList, context) {
    return new FileUpload(fileList, context, this.options)
  };

  /**
   * A FormulateForm failed to submit due to existing validation errors.
   */
  Formulate.prototype.failedValidation = function failedValidation (form) {
    return this.options.failedValidation(this)
  };

  var Formulate$1 = new Formulate();

  return Formulate$1;

})(isPlainObject, VueFormulateI18n);
